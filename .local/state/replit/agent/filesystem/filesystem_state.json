{"file_contents":{"ai_chat.py":{"content":"import streamlit as st\nimport os\nimport json\nfrom openai import OpenAI\n\n# Using GPT-4o for advanced cybersecurity analysis and recommendations\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\nOPENAI_MODELS = [\"gpt-4o-mini\", \"gpt-4o\", \"gpt-4\"]  # Fallback model priority\n\n# Initialize OpenAI client if API key is available\nopenai = OpenAI(api_key=OPENAI_API_KEY) if OPENAI_API_KEY else None\n\nSECURITY_SYSTEM_PROMPT = \"\"\"\nYou are an expert cybersecurity AI assistant specializing in:\n- Network security analysis and threat assessment\n- Vulnerability identification and remediation\n- Penetration testing methodologies and best practices\n- CVE analysis and risk evaluation\n- Security compliance frameworks (OWASP, PCI-DSS, HIPAA)\n- Incident response and forensics\n- Security architecture and defense strategies\n\nProvide detailed, actionable security advice. When discussing vulnerabilities:\n1. Explain the technical details clearly\n2. Assess the risk level and potential impact\n3. Provide specific remediation steps\n4. Reference relevant compliance frameworks\n5. Suggest additional security measures\n\nAlways prioritize ethical security practices and responsible disclosure.\n\"\"\"\n\ndef initialize_chat():\n    \"\"\"Initialize chat session\"\"\"\n    if 'chat_messages' not in st.session_state:\n        st.session_state.chat_messages = [\n            {\n                \"role\": \"assistant\",\n                \"content\": \"üõ°Ô∏è **CyberSec AI Assistant Ready**\\n\\nI'm your specialized cybersecurity AI assistant. I can help you with:\\n\\n- üîç **Security Analysis** - Analyze vulnerabilities and threats\\n- üõ†Ô∏è **Remediation Guidance** - Step-by-step fix recommendations\\n- üìã **Compliance Mapping** - OWASP, PCI-DSS, HIPAA alignment\\n- üéØ **Penetration Testing** - Methodology and best practices\\n- üö® **Incident Response** - Threat analysis and containment\\n\\nWhat security challenge can I help you tackle today?\"\n            }\n        ]\n\ndef get_ai_response(user_message, context=None):\n    \"\"\"Get AI response for security queries\"\"\"\n    if not openai or not OPENAI_API_KEY:\n        return \"‚ùå **OpenAI API Key Required**: Please configure your OPENAI_API_KEY to use AI features.\"\n    \n    try:\n        messages = [{\"role\": \"system\", \"content\": SECURITY_SYSTEM_PROMPT}]\n        \n        # Add context if provided (e.g., scan results)\n        if context:\n            context_message = f\"Additional context for analysis:\\n{context}\"\n            messages.append({\"role\": \"user\", \"content\": context_message})\n        \n        # Add chat history (last 10 messages for context) - safely get from session state\n        chat_messages = st.session_state.get('chat_messages', [])\n        recent_messages = chat_messages[-10:] if chat_messages else []\n        for msg in recent_messages:\n            messages.append({\"role\": msg[\"role\"], \"content\": msg[\"content\"]})\n        \n        # Add current user message\n        messages.append({\"role\": \"user\", \"content\": user_message})\n        \n        # Try models in order of preference\n        last_error = None\n        for model in OPENAI_MODELS:\n            try:\n                response = openai.chat.completions.create(\n                    model=model,\n                    messages=messages,\n                    max_tokens=2000\n                )\n                return response.choices[0].message.content\n            except Exception as model_error:\n                last_error = model_error\n                continue\n        \n        # If all models failed\n        return f\"‚ùå **AI Service Error**: {str(last_error)}\\n\\nPlease try again later or check your API key configuration.\"\n        \n    except Exception as e:\n        return f\"‚ùå **Error**: {str(e)}\\n\\nPlease check your OpenAI API key configuration.\"\n\ndef analyze_scan_results(scan_type, results):\n    \"\"\"Analyze scan results with AI\"\"\"\n    context_prompt = f\"\"\"\n    Analyze these {scan_type} scan results and provide:\n    1. Risk assessment and severity levels\n    2. Detailed vulnerability explanations\n    3. Specific remediation steps\n    4. Compliance framework mapping\n    5. Additional security recommendations\n    \n    Scan Results:\n    {json.dumps(results, indent=2)}\n    \"\"\"\n    \n    return get_ai_response(\"Please analyze these scan results comprehensively.\", context_prompt)\n\ndef get_security_recommendations(target_type, target_info):\n    \"\"\"Get security recommendations for specific targets\"\"\"\n    prompt = f\"\"\"\n    Provide comprehensive security recommendations for this {target_type}:\n    \n    Target Information:\n    {json.dumps(target_info, indent=2)}\n    \n    Please include:\n    1. Security hardening steps\n    2. Monitoring recommendations\n    3. Compliance considerations\n    4. Risk mitigation strategies\n    \"\"\"\n    \n    return get_ai_response(prompt)\n\ndef render_chat_interface():\n    \"\"\"Render the AI chat interface\"\"\"\n    st.title(\"ü§ñ AI Security Chat Assistant\")\n    \n    initialize_chat()\n    \n    # Chat container\n    chat_container = st.container()\n    \n    with chat_container:\n        for message in st.session_state.chat_messages:\n            with st.chat_message(message[\"role\"]):\n                st.markdown(message[\"content\"])\n    \n    # Chat input\n    if prompt := st.chat_input(\"Ask me about cybersecurity...\"):\n        # Add user message\n        st.session_state.chat_messages.append({\"role\": \"user\", \"content\": prompt})\n        \n        with st.chat_message(\"user\"):\n            st.markdown(prompt)\n        \n        # Get AI response\n        with st.chat_message(\"assistant\"):\n            with st.spinner(\"üß† Analyzing security context...\"):\n                response = get_ai_response(prompt)\n                st.markdown(response)\n                \n                # Add assistant response to chat history\n                st.session_state.chat_messages.append({\"role\": \"assistant\", \"content\": response})\n    \n    # Sidebar with quick actions\n    with st.sidebar:\n        st.markdown(\"### üöÄ Quick Security Actions\")\n        \n        if st.button(\"üîç Analyze Last Scan\"):\n            user_info = st.session_state.get('user_info', {})\n            if user_info:\n                from database import get_user_scans\n                recent_scans = get_user_scans(user_info['id'], 1)\n                if recent_scans:\n                    scan = recent_scans[0]\n                    prompt = f\"Analyze my recent {scan['scan_type']} scan of {scan['target']}\"\n                    st.session_state.chat_messages.append({\"role\": \"user\", \"content\": prompt})\n                    \n                    with st.spinner(\"üß† Analyzing scan results...\"):\n                        response = analyze_scan_results(scan['scan_type'], scan['results'])\n                        st.session_state.chat_messages.append({\"role\": \"assistant\", \"content\": response})\n                    st.rerun()\n                else:\n                    st.warning(\"No recent scans found\")\n            else:\n                st.error(\"Please log in first\")\n        \n        if st.button(\"üõ°Ô∏è Security Best Practices\"):\n            prompt = \"What are the top 10 cybersecurity best practices for organizations in 2025?\"\n            st.session_state.chat_messages.append({\"role\": \"user\", \"content\": prompt})\n            \n            with st.spinner(\"üß† Generating recommendations...\"):\n                response = get_ai_response(prompt)\n                st.session_state.chat_messages.append({\"role\": \"assistant\", \"content\": response})\n            st.rerun()\n        \n        if st.button(\"üö® Incident Response Guide\"):\n            prompt = \"Provide a comprehensive incident response checklist for a potential security breach\"\n            st.session_state.chat_messages.append({\"role\": \"user\", \"content\": prompt})\n            \n            with st.spinner(\"üß† Creating incident response guide...\"):\n                response = get_ai_response(prompt)\n                st.session_state.chat_messages.append({\"role\": \"assistant\", \"content\": response})\n            st.rerun()\n        \n        if st.button(\"üîÑ Clear Chat\"):\n            st.session_state.chat_messages = [st.session_state.chat_messages[0]]  # Keep welcome message\n            st.rerun()\n\ndef get_vulnerability_explanation(vulnerability_name):\n    \"\"\"Get detailed explanation of a specific vulnerability\"\"\"\n    prompt = f\"\"\"\n    Provide a comprehensive analysis of the {vulnerability_name} vulnerability including:\n    1. Technical description and how it works\n    2. Potential impact and risk level\n    3. Common attack vectors\n    4. Detection methods\n    5. Remediation steps\n    6. Prevention strategies\n    \"\"\"\n    \n    return get_ai_response(prompt)\n","size_bytes":8608},"app.py":{"content":"import streamlit as st\nimport sqlite3\nfrom auth import init_auth, check_authentication\nfrom database import init_database\nfrom dashboard import render_dashboard\nimport os\n\n# Page configuration\nst.set_page_config(\n    page_title=\"CyberSec AI Platform\",\n    page_icon=\"üõ°Ô∏è\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Initialize database and authentication\ninit_database()\ninit_auth()\n\n# Custom CSS for animations and styling\nst.markdown(\"\"\"\n<style>\n    .metric-card {\n        background: linear-gradient(45deg, #FF4B4B, #FF6B6B);\n        padding: 1rem;\n        border-radius: 10px;\n        margin: 0.5rem 0;\n        animation: pulse 2s infinite;\n    }\n    \n    @keyframes pulse {\n        0% { transform: scale(1); }\n        50% { transform: scale(1.05); }\n        100% { transform: scale(1); }\n    }\n    \n    .threat-alert {\n        background: linear-gradient(45deg, #FF4B4B, #FF0000);\n        padding: 1rem;\n        border-radius: 10px;\n        animation: blink 1s infinite;\n    }\n    \n    @keyframes blink {\n        0%, 50% { opacity: 1; }\n        51%, 100% { opacity: 0.7; }\n    }\n    \n    .scan-progress {\n        background: linear-gradient(90deg, #00FF00, #32CD32);\n        height: 20px;\n        border-radius: 10px;\n        animation: progress 3s ease-in-out infinite;\n    }\n    \n    @keyframes progress {\n        0% { width: 0%; }\n        100% { width: 100%; }\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\ndef main():\n    # Check authentication\n    if not check_authentication():\n        st.title(\"üõ°Ô∏è CyberSec AI Platform\")\n        st.error(\"Please log in to access the platform\")\n        return\n    \n    # Sidebar navigation\n    with st.sidebar:\n        st.title(\"üõ°Ô∏è CyberSec AI\")\n        st.markdown(\"---\")\n        \n        # User info\n        user_info = st.session_state.get('user_info', {})\n        st.write(f\"üë§ **{user_info.get('username', 'Unknown User')}**\")\n        st.write(f\"üéñÔ∏è **{user_info.get('role', 'free').title()} Tier**\")\n        \n        # Usage tracking\n        usage = st.session_state.get('usage', {'scans': 0, 'limit': 5 if user_info.get('role') == 'free' else 999})\n        progress = min(usage['scans'] / usage['limit'], 1.0)\n        st.progress(progress)\n        st.caption(f\"Scans used: {usage['scans']}/{usage['limit']}\")\n        \n        st.markdown(\"---\")\n        \n        # Navigation\n        st.markdown(\"### üß≠ Navigation\")\n        st.markdown(\"Use the pages in the sidebar to access different tools:\")\n        st.markdown(\"- ü§ñ AI Security Chat\")\n        st.markdown(\"- üîç Network Scanner\")\n        st.markdown(\"- üåê Web Vulnerability Scanner\")\n        st.markdown(\"- üõ°Ô∏è CVE Database\")\n        st.markdown(\"- üåç Shodan Intelligence\")\n        st.markdown(\"- üí• Exploit Database\")\n        st.markdown(\"- üìä Reports\")\n        st.markdown(\"- üí≥ Billing\")\n        \n        st.markdown(\"---\")\n        \n        if st.button(\"üö™ Logout\"):\n            for key in list(st.session_state.keys()):\n                del st.session_state[key]\n            st.rerun()\n    \n    # Main dashboard\n    render_dashboard()\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":3143},"auth.py":{"content":"import streamlit as st\nimport sqlite3\nimport jwt\nimport datetime\nimport os\nfrom argon2 import PasswordHasher\nfrom argon2.exceptions import VerifyMismatchError\nfrom database import get_db_connection\n\n# Secure session secret - required in production\nSESSION_SECRET = os.getenv(\"SESSION_SECRET\")\nif not SESSION_SECRET:\n    if os.getenv(\"DEV_MODE\", \"false\").lower() == \"true\":\n        SESSION_SECRET = \"dev_secret_key_not_for_production\"\n    else:\n        raise ValueError(\"SESSION_SECRET environment variable is required for production\")\n\n# Initialize secure password hasher\nph = PasswordHasher()\n\ndef init_auth():\n    \"\"\"Initialize authentication system\"\"\"\n    if 'authenticated' not in st.session_state:\n        st.session_state.authenticated = False\n    if 'user_info' not in st.session_state:\n        st.session_state.user_info = {}\n\ndef hash_password(password):\n    \"\"\"Hash password using Argon2\"\"\"\n    return ph.hash(password)\n\ndef verify_password(password, hashed):\n    \"\"\"Verify password against Argon2 hash\"\"\"\n    try:\n        ph.verify(hashed, password)\n        return True\n    except VerifyMismatchError:\n        return False\n\ndef create_jwt_token(user_id, username, role):\n    \"\"\"Create JWT token for user session\"\"\"\n    payload = {\n        'user_id': user_id,\n        'username': username,\n        'role': role,\n        'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=24)\n    }\n    token = jwt.encode(payload, SESSION_SECRET, algorithm='HS256')\n    return token\n\ndef verify_jwt_token(token):\n    \"\"\"Verify JWT token\"\"\"\n    try:\n        payload = jwt.decode(token, SESSION_SECRET, algorithms=['HS256'])\n        return payload\n    except jwt.ExpiredSignatureError:\n        return None\n    except jwt.InvalidTokenError:\n        return None\n\ndef register_user(username, email, password):\n    \"\"\"Register new user\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    # Check if user exists\n    cursor.execute(\"SELECT id FROM users WHERE username = ? OR email = ?\", (username, email))\n    if cursor.fetchone():\n        conn.close()\n        return False, \"User already exists\"\n    \n    # Create user\n    hashed_password = hash_password(password)\n    cursor.execute(\"\"\"\n        INSERT INTO users (username, email, password_hash, role, created_at)\n        VALUES (?, ?, ?, 'free', ?)\n    \"\"\", (username, email, hashed_password, datetime.datetime.now()))\n    \n    user_id = cursor.lastrowid\n    conn.commit()\n    conn.close()\n    \n    return True, user_id\n\ndef authenticate_user(username, password):\n    \"\"\"Authenticate user login\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"\"\"\n        SELECT id, username, email, role, password_hash FROM users \n        WHERE username = ?\n    \"\"\", (username,))\n    \n    user = cursor.fetchone()\n    conn.close()\n    \n    if user and verify_password(password, user[4]):\n        return True, {\n            'id': user[0],\n            'username': user[1],\n            'email': user[2],\n            'role': user[3]\n        }\n    return False, None\n\ndef check_authentication():\n    \"\"\"Check if user is authenticated and show login/register if not\"\"\"\n    if st.session_state.get('authenticated', False):\n        return True\n    \n    # Login/Register tabs\n    tab1, tab2 = st.tabs([\"üîê Login\", \"üìù Register\"])\n    \n    with tab1:\n        st.subheader(\"Login to CyberSec AI Platform\")\n        with st.form(\"login_form\"):\n            username = st.text_input(\"Username\")\n            password = st.text_input(\"Password\", type=\"password\")\n            submitted = st.form_submit_button(\"üöÄ Login\")\n            \n            if submitted:\n                if username and password:\n                    success, user_info = authenticate_user(username, password)\n                    if success and user_info:\n                        st.session_state.authenticated = True\n                        st.session_state.user_info = user_info\n                        st.session_state.jwt_token = create_jwt_token(\n                            user_info['id'], user_info['username'], user_info['role']\n                        )\n                        st.success(\"Login successful!\")\n                        st.rerun()\n                    else:\n                        st.error(\"Invalid credentials\")\n                else:\n                    st.error(\"Please fill in all fields\")\n    \n    with tab2:\n        st.subheader(\"Create New Account\")\n        with st.form(\"register_form\"):\n            new_username = st.text_input(\"Choose Username\")\n            new_email = st.text_input(\"Email Address\")\n            new_password = st.text_input(\"Password\", type=\"password\")\n            confirm_password = st.text_input(\"Confirm Password\", type=\"password\")\n            submitted = st.form_submit_button(\"üéØ Create Account\")\n            \n            if submitted:\n                if new_username and new_email and new_password and confirm_password:\n                    if new_password != confirm_password:\n                        st.error(\"Passwords don't match\")\n                    elif len(new_password) < 6:\n                        st.error(\"Password must be at least 6 characters\")\n                    else:\n                        success, result = register_user(new_username, new_email, new_password)\n                        if success:\n                            st.success(\"Account created successfully! Please login.\")\n                        else:\n                            st.error(result)\n                else:\n                    st.error(\"Please fill in all fields\")\n    \n    return False\n\ndef get_user_usage():\n    \"\"\"Get user's current usage statistics\"\"\"\n    user_info = st.session_state.get('user_info', {})\n    if not user_info:\n        return {'scans': 0, 'limit': 5}\n    \n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    # Get scan count for current month\n    cursor.execute(\"\"\"\n        SELECT COUNT(*) FROM scan_results \n        WHERE user_id = ? AND strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now')\n    \"\"\", (user_info['id'],))\n    \n    scan_count = cursor.fetchone()[0]\n    conn.close()\n    \n    # Set limits based on role\n    limit = 999 if user_info.get('role') == 'pro' else 5\n    \n    return {'scans': scan_count, 'limit': limit}\n\ndef check_scan_limit():\n    \"\"\"Check if user has reached scan limit\"\"\"\n    usage = get_user_usage()\n    st.session_state.usage = usage\n    \n    if usage['scans'] >= usage['limit']:\n        st.error(\"üö´ Scan limit reached! Upgrade to Pro for unlimited scans.\")\n        return False\n    return True\n","size_bytes":6565},"billing.py":{"content":"import stripe\nimport streamlit as st\nimport os\nfrom datetime import datetime, timedelta\nfrom database import get_db_connection\nimport json\n\n# Stripe configuration\nSTRIPE_SECRET_KEY = os.getenv(\"STRIPE_SECRET_KEY\", \"\")\nSTRIPE_PUBLISHABLE_KEY = os.getenv(\"STRIPE_PUBLISHABLE_KEY\", \"\")\n\nif STRIPE_SECRET_KEY:\n    stripe.api_key = STRIPE_SECRET_KEY\n\n# Pricing plans\nPRICING_PLANS = {\n    \"free\": {\n        \"name\": \"Free Tier\",\n        \"price\": 0,\n        \"scans_per_month\": 5,\n        \"features\": [\n            \"5 scans per month\",\n            \"Basic vulnerability scanning\",\n            \"CVE database access\",\n            \"Community support\"\n        ],\n        \"stripe_price_id\": None\n    },\n    \"pro\": {\n        \"name\": \"Professional\",\n        \"price\": 29.99,\n        \"scans_per_month\": 999999,  # Unlimited\n        \"features\": [\n            \"Unlimited scans\",\n            \"Advanced vulnerability assessment\",\n            \"Shodan integration\",\n            \"PDF report generation\",\n            \"AI-powered analysis\",\n            \"Priority support\",\n            \"Compliance mapping\"\n        ],\n        \"stripe_price_id\": os.getenv(\"STRIPE_PRO_PRICE_ID\", \"\")\n    },\n    \"enterprise\": {\n        \"name\": \"Enterprise\",\n        \"price\": 99.99,\n        \"scans_per_month\": 999999,  # Unlimited\n        \"features\": [\n            \"Everything in Professional\",\n            \"White-label reports\",\n            \"API access\",\n            \"Custom integrations\",\n            \"Dedicated support\",\n            \"SLA guarantee\",\n            \"Team management\"\n        ],\n        \"stripe_price_id\": os.getenv(\"STRIPE_ENTERPRISE_PRICE_ID\", \"\")\n    }\n}\n\ndef create_stripe_customer(user_info):\n    \"\"\"Create a Stripe customer\"\"\"\n    if not STRIPE_SECRET_KEY:\n        raise Exception(\"Stripe not configured\")\n    \n    try:\n        customer = stripe.Customer.create(\n            email=user_info['email'],\n            name=user_info['username'],\n            metadata={\n                'user_id': user_info['id'],\n                'username': user_info['username']\n            }\n        )\n        \n        # Update user record with Stripe customer ID\n        conn = get_db_connection()\n        cursor = conn.cursor()\n        \n        cursor.execute(\"\"\"\n            UPDATE users SET stripe_customer_id = ? WHERE id = ?\n        \"\"\", (customer.id, user_info['id']))\n        \n        conn.commit()\n        conn.close()\n        \n        return customer.id\n        \n    except stripe.error.StripeError as e:\n        raise Exception(f\"Stripe error: {str(e)}\")\n\ndef get_or_create_customer(user_info):\n    \"\"\"Get existing Stripe customer or create new one\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"SELECT stripe_customer_id FROM users WHERE id = ?\", (user_info['id'],))\n    result = cursor.fetchone()\n    conn.close()\n    \n    if result and result[0]:\n        return result[0]\n    else:\n        return create_stripe_customer(user_info)\n\ndef create_checkout_session(user_info, plan_id):\n    \"\"\"Create Stripe checkout session\"\"\"\n    if not STRIPE_SECRET_KEY:\n        raise Exception(\"Stripe not configured\")\n    \n    if plan_id not in PRICING_PLANS or plan_id == \"free\":\n        raise Exception(\"Invalid plan selected\")\n    \n    plan = PRICING_PLANS[plan_id]\n    customer_id = get_or_create_customer(user_info)\n    \n    try:\n        session = stripe.checkout.Session.create(\n            customer=customer_id,\n            payment_method_types=['card'],\n            line_items=[{\n                'price': plan['stripe_price_id'],\n                'quantity': 1,\n            }],\n            mode='subscription',\n            success_url=f\"{os.getenv('BASE_URL', 'http://localhost:5000')}/billing?session_id={{CHECKOUT_SESSION_ID}}\",\n            cancel_url=f\"{os.getenv('BASE_URL', 'http://localhost:5000')}/billing?canceled=true\",\n            metadata={\n                'user_id': user_info['id'],\n                'plan': plan_id\n            }\n        )\n        \n        return session.url\n        \n    except stripe.error.StripeError as e:\n        raise Exception(f\"Checkout session creation failed: {str(e)}\")\n\ndef get_customer_subscriptions(customer_id):\n    \"\"\"Get customer's active subscriptions\"\"\"\n    if not STRIPE_SECRET_KEY:\n        return []\n    \n    try:\n        subscriptions = stripe.Subscription.list(\n            customer=customer_id,\n            status='active'\n        )\n        return subscriptions.data\n        \n    except stripe.error.StripeError:\n        return []\n\ndef cancel_subscription(subscription_id):\n    \"\"\"Cancel a subscription\"\"\"\n    if not STRIPE_SECRET_KEY:\n        raise Exception(\"Stripe not configured\")\n    \n    try:\n        subscription = stripe.Subscription.delete(subscription_id)\n        return subscription\n        \n    except stripe.error.StripeError as e:\n        raise Exception(f\"Subscription cancellation failed: {str(e)}\")\n\ndef update_user_subscription_status(user_id, plan, subscription_id=None):\n    \"\"\"Update user's subscription status in database\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"\"\"\n        UPDATE users \n        SET role = ?, subscription_id = ?, subscription_updated_at = ?\n        WHERE id = ?\n    \"\"\", (plan, subscription_id, datetime.now(), user_id))\n    \n    conn.commit()\n    conn.close()\n\ndef get_usage_statistics(user_id):\n    \"\"\"Get user's current usage statistics\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    # Get current month usage\n    cursor.execute(\"\"\"\n        SELECT COUNT(*) FROM scan_results \n        WHERE user_id = ? AND strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now')\n    \"\"\", (user_id,))\n    \n    monthly_scans = cursor.fetchone()[0]\n    \n    # Get total usage\n    cursor.execute(\"SELECT COUNT(*) FROM scan_results WHERE user_id = ?\", (user_id,))\n    total_scans = cursor.fetchone()[0]\n    \n    # Get reports generated\n    cursor.execute(\"SELECT COUNT(*) FROM reports WHERE user_id = ?\", (user_id,))\n    total_reports = cursor.fetchone()[0]\n    \n    conn.close()\n    \n    return {\n        'monthly_scans': monthly_scans,\n        'total_scans': total_scans,\n        'total_reports': total_reports\n    }\n\ndef render_billing_interface():\n    \"\"\"Render billing and subscription interface\"\"\"\n    st.title(\"üí≥ Billing & Subscription Management\")\n    \n    user_info = st.session_state.get('user_info', {})\n    if not user_info:\n        st.error(\"Please log in to access billing\")\n        return\n    \n    # Current subscription info\n    current_plan = user_info.get('role', 'free')\n    \n    st.markdown(\"### üìä Current Subscription\")\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        st.metric(\"Current Plan\", PRICING_PLANS[current_plan]['name'])\n    \n    with col2:\n        st.metric(\"Monthly Price\", f\"${PRICING_PLANS[current_plan]['price']}\")\n    \n    with col3:\n        st.metric(\"Monthly Scans\", \n                 \"Unlimited\" if PRICING_PLANS[current_plan]['scans_per_month'] > 1000 \n                 else str(PRICING_PLANS[current_plan]['scans_per_month']))\n    \n    # Usage statistics\n    usage_stats = get_usage_statistics(user_info['id'])\n    \n    st.markdown(\"### üìà Usage Statistics\")\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        st.metric(\"This Month's Scans\", usage_stats['monthly_scans'])\n    \n    with col2:\n        st.metric(\"Total Scans\", usage_stats['total_scans'])\n    \n    with col3:\n        st.metric(\"Reports Generated\", usage_stats['total_reports'])\n    \n    # Pricing plans\n    st.markdown(\"### üí∞ Available Plans\")\n    \n    # Plan comparison\n    plan_cols = st.columns(len(PRICING_PLANS))\n    \n    for i, (plan_id, plan_info) in enumerate(PRICING_PLANS.items()):\n        with plan_cols[i]:\n            # Plan card\n            is_current = current_plan == plan_id\n            \n            if is_current:\n                st.success(f\"‚úÖ **{plan_info['name']}** (Current)\")\n            else:\n                st.markdown(f\"**{plan_info['name']}**\")\n            \n            st.markdown(f\"### ${plan_info['price']}/month\")\n            \n            st.markdown(\"**Features:**\")\n            for feature in plan_info['features']:\n                st.markdown(f\"‚Ä¢ {feature}\")\n            \n            if not is_current and plan_id != 'free':\n                if st.button(f\"Upgrade to {plan_info['name']}\", key=f\"upgrade_{plan_id}\"):\n                    try:\n                        checkout_url = create_checkout_session(user_info, plan_id)\n                        st.markdown(f\"[Complete Purchase]({checkout_url})\")\n                        st.success(\"Click the link above to complete your subscription\")\n                    except Exception as e:\n                        st.error(f\"Error creating checkout session: {str(e)}\")\n            \n            if is_current and plan_id != 'free':\n                if st.button(\"Cancel Subscription\", key=f\"cancel_{plan_id}\"):\n                    st.warning(\"Are you sure you want to cancel your subscription?\")\n                    if st.button(\"Yes, Cancel\", key=f\"confirm_cancel_{plan_id}\"):\n                        # In a real implementation, this would cancel via Stripe\n                        st.success(\"Subscription canceled (demo)\")\n    \n    # Billing history\n    st.markdown(\"### üìÑ Billing History\")\n    \n    if STRIPE_SECRET_KEY and user_info.get('stripe_customer_id'):\n        try:\n            customer_id = user_info['stripe_customer_id']\n            \n            # Get invoices\n            invoices = stripe.Invoice.list(customer=customer_id, limit=10)\n            \n            if invoices.data:\n                invoice_data = []\n                for invoice in invoices.data:\n                    invoice_data.append([\n                        datetime.fromtimestamp(invoice.created).strftime('%Y-%m-%d'),\n                        f\"${invoice.amount_paid / 100:.2f}\",\n                        invoice.status.title(),\n                        invoice.hosted_invoice_url or \"N/A\"\n                    ])\n                \n                st.table({\n                    'Date': [row[0] for row in invoice_data],\n                    'Amount': [row[1] for row in invoice_data],\n                    'Status': [row[2] for row in invoice_data],\n                    'Invoice': [row[3] for row in invoice_data]\n                })\n            else:\n                st.info(\"No billing history available\")\n                \n        except Exception as e:\n            st.error(f\"Error loading billing history: {str(e)}\")\n    else:\n        st.info(\"Connect Stripe to view billing history\")\n    \n    # Payment methods\n    st.markdown(\"### üí≥ Payment Methods\")\n    \n    if STRIPE_SECRET_KEY:\n        st.info(\"Payment methods are managed through Stripe's secure portal\")\n        if st.button(\"Manage Payment Methods\"):\n            st.info(\"This would redirect to Stripe's customer portal\")\n    else:\n        st.warning(\"‚ö†Ô∏è Stripe integration not configured. Payment processing is unavailable.\")\n        st.markdown(\"\"\"\n        **To enable billing:**\n        1. Set up a Stripe account at [stripe.com](https://stripe.com)\n        2. Configure environment variables:\n           - `STRIPE_SECRET_KEY`\n           - `STRIPE_PUBLISHABLE_KEY`\n           - `STRIPE_PRO_PRICE_ID`\n           - `STRIPE_ENTERPRISE_PRICE_ID`\n        3. Set up webhook endpoints for subscription events\n        \"\"\")\n\ndef handle_stripe_webhook(payload, sig_header):\n    \"\"\"Handle Stripe webhook events\"\"\"\n    if not STRIPE_SECRET_KEY:\n        return False\n    \n    endpoint_secret = os.getenv(\"STRIPE_WEBHOOK_SECRET\", \"\")\n    \n    try:\n        event = stripe.Webhook.construct_event(\n            payload, sig_header, endpoint_secret\n        )\n        \n        # Handle subscription events\n        if event['type'] == 'customer.subscription.created':\n            subscription = event['data']['object']\n            customer_id = subscription['customer']\n            \n            # Get user by customer ID\n            conn = get_db_connection()\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT id FROM users WHERE stripe_customer_id = ?\", (customer_id,))\n            user = cursor.fetchone()\n            \n            if user:\n                # Update subscription status\n                plan = 'pro'  # Determine plan from subscription\n                update_user_subscription_status(user[0], plan, subscription['id'])\n            \n            conn.close()\n            \n        elif event['type'] == 'customer.subscription.deleted':\n            subscription = event['data']['object']\n            customer_id = subscription['customer']\n            \n            # Downgrade user to free plan\n            conn = get_db_connection()\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT id FROM users WHERE stripe_customer_id = ?\", (customer_id,))\n            user = cursor.fetchone()\n            \n            if user:\n                update_user_subscription_status(user[0], 'free', None)\n            \n            conn.close()\n        \n        return True\n        \n    except Exception as e:\n        print(f\"Webhook error: {str(e)}\")\n        return False\n\ndef check_subscription_limits(user_info):\n    \"\"\"Check if user has exceeded subscription limits\"\"\"\n    current_plan = user_info.get('role', 'free')\n    plan_limits = PRICING_PLANS[current_plan]\n    \n    usage_stats = get_usage_statistics(user_info['id'])\n    monthly_scans = usage_stats['monthly_scans']\n    \n    if monthly_scans >= plan_limits['scans_per_month']:\n        return False, f\"Monthly scan limit reached ({plan_limits['scans_per_month']})\"\n    \n    return True, f\"{monthly_scans}/{plan_limits['scans_per_month']} scans used\"\n\ndef get_billing_analytics():\n    \"\"\"Get billing analytics for admin dashboard\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    # Count users by plan\n    cursor.execute(\"\"\"\n        SELECT role, COUNT(*) \n        FROM users \n        GROUP BY role\n    \"\"\")\n    \n    plan_counts = dict(cursor.fetchall())\n    \n    # Revenue calculation (simplified)\n    monthly_revenue = (\n        plan_counts.get('pro', 0) * PRICING_PLANS['pro']['price'] +\n        plan_counts.get('enterprise', 0) * PRICING_PLANS['enterprise']['price']\n    )\n    \n    conn.close()\n    \n    return {\n        'total_users': sum(plan_counts.values()),\n        'free_users': plan_counts.get('free', 0),\n        'pro_users': plan_counts.get('pro', 0),\n        'enterprise_users': plan_counts.get('enterprise', 0),\n        'monthly_revenue': monthly_revenue\n    }\n","size_bytes":14495},"cve_database.py":{"content":"import requests\nimport streamlit as st\nimport json\nfrom datetime import datetime, timedelta\nimport time\nfrom database import cache_cve_data, get_cached_cve_data\n\n# NVD API Configuration\nNVD_BASE_URL = \"https://services.nvd.nist.gov/rest/json/cves/2.0\"\nAPI_KEY = \"\"  # Optional: Add NVD API key for higher rate limits\n\ndef get_cvss_color(score):\n    \"\"\"Get color code for CVSS score\"\"\"\n    if score >= 9.0:\n        return \"üî¥\"  # Critical\n    elif score >= 7.0:\n        return \"üü†\"  # High\n    elif score >= 4.0:\n        return \"üü°\"  # Medium\n    elif score >= 0.1:\n        return \"üü¢\"  # Low\n    else:\n        return \"‚ö™\"  # None/Unknown\n\ndef get_severity_from_score(score):\n    \"\"\"Get severity level from CVSS score\"\"\"\n    if score >= 9.0:\n        return \"CRITICAL\"\n    elif score >= 7.0:\n        return \"HIGH\"\n    elif score >= 4.0:\n        return \"MEDIUM\"\n    elif score >= 0.1:\n        return \"LOW\"\n    else:\n        return \"NONE\"\n\ndef search_cves_by_keyword(keyword, limit=20):\n    \"\"\"Search CVEs by keyword using NVD API\"\"\"\n    try:\n        params = {\n            'keywordSearch': keyword,\n            'resultsPerPage': limit,\n            'startIndex': 0\n        }\n        \n        headers = {}\n        if API_KEY:\n            headers['apiKey'] = API_KEY\n        \n        response = requests.get(NVD_BASE_URL, params=params, headers=headers, timeout=30)\n        \n        if response.status_code == 200:\n            data = response.json()\n            vulnerabilities = []\n            \n            for item in data.get('vulnerabilities', []):\n                cve = item.get('cve', {})\n                cve_id = cve.get('id', 'Unknown')\n                \n                # Get description\n                descriptions = cve.get('descriptions', [])\n                description = \"\"\n                for desc in descriptions:\n                    if desc.get('lang') == 'en':\n                        description = desc.get('value', '')\n                        break\n                \n                # Get CVSS score\n                metrics = cve.get('metrics', {})\n                cvss_score = 0.0\n                \n                # Try CVSS v3.1 first, then v3.0, then v2.0\n                for version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:\n                    if version in metrics and metrics[version]:\n                        metric = metrics[version][0]\n                        if 'cvssData' in metric:\n                            cvss_score = metric['cvssData'].get('baseScore', 0.0)\n                            break\n                \n                # Get dates\n                published = cve.get('published', '')\n                modified = cve.get('lastModified', '')\n                \n                vulnerability = {\n                    'cve_id': cve_id,\n                    'description': description,\n                    'cvss_score': cvss_score,\n                    'severity': get_severity_from_score(cvss_score),\n                    'published_date': published,\n                    'modified_date': modified\n                }\n                \n                vulnerabilities.append(vulnerability)\n                \n                # Cache the CVE data\n                cache_cve_data(\n                    cve_id, description, cvss_score,\n                    get_severity_from_score(cvss_score),\n                    published, modified\n                )\n            \n            return vulnerabilities\n            \n        else:\n            st.error(f\"NVD API Error: {response.status_code}\")\n            return []\n            \n    except Exception as e:\n        st.error(f\"Error searching CVEs: {str(e)}\")\n        return []\n\ndef get_cve_details(cve_id):\n    \"\"\"Get detailed information for a specific CVE\"\"\"\n    # First check cache\n    cached_data = get_cached_cve_data(cve_id)\n    if cached_data:\n        return cached_data\n    \n    try:\n        params = {\n            'cveId': cve_id\n        }\n        \n        headers = {}\n        if API_KEY:\n            headers['apiKey'] = API_KEY\n        \n        response = requests.get(NVD_BASE_URL, params=params, headers=headers, timeout=30)\n        \n        if response.status_code == 200:\n            data = response.json()\n            \n            if data.get('vulnerabilities'):\n                item = data['vulnerabilities'][0]\n                cve = item.get('cve', {})\n                \n                # Get description\n                descriptions = cve.get('descriptions', [])\n                description = \"\"\n                for desc in descriptions:\n                    if desc.get('lang') == 'en':\n                        description = desc.get('value', '')\n                        break\n                \n                # Get CVSS score and vector\n                metrics = cve.get('metrics', {})\n                cvss_score = 0.0\n                cvss_vector = \"\"\n                \n                for version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:\n                    if version in metrics and metrics[version]:\n                        metric = metrics[version][0]\n                        if 'cvssData' in metric:\n                            cvss_score = metric['cvssData'].get('baseScore', 0.0)\n                            cvss_vector = metric['cvssData'].get('vectorString', '')\n                            break\n                \n                # Get references\n                references = []\n                for ref in cve.get('references', []):\n                    references.append({\n                        'url': ref.get('url', ''),\n                        'source': ref.get('source', ''),\n                        'tags': ref.get('tags', [])\n                    })\n                \n                cve_details = {\n                    'cve_id': cve_id,\n                    'description': description,\n                    'cvss_score': cvss_score,\n                    'cvss_vector': cvss_vector,\n                    'severity': get_severity_from_score(cvss_score),\n                    'published_date': cve.get('published', ''),\n                    'modified_date': cve.get('lastModified', ''),\n                    'references': references\n                }\n                \n                # Cache the detailed data\n                cache_cve_data(\n                    cve_id, description, cvss_score,\n                    get_severity_from_score(cvss_score),\n                    cve.get('published', ''), cve.get('lastModified', '')\n                )\n                \n                return cve_details\n        \n        return None\n        \n    except Exception as e:\n        st.error(f\"Error getting CVE details: {str(e)}\")\n        return None\n\ndef get_recent_cves(days=7, limit=50):\n    \"\"\"Get recent CVEs from the last N days\"\"\"\n    try:\n        end_date = datetime.now()\n        start_date = end_date - timedelta(days=days)\n        \n        params = {\n            'pubStartDate': start_date.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z',\n            'pubEndDate': end_date.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z',\n            'resultsPerPage': limit,\n            'startIndex': 0\n        }\n        \n        headers = {}\n        if API_KEY:\n            headers['apiKey'] = API_KEY\n        \n        response = requests.get(NVD_BASE_URL, params=params, headers=headers, timeout=30)\n        \n        if response.status_code == 200:\n            data = response.json()\n            vulnerabilities = []\n            \n            for item in data.get('vulnerabilities', []):\n                cve = item.get('cve', {})\n                cve_id = cve.get('id', 'Unknown')\n                \n                # Get description\n                descriptions = cve.get('descriptions', [])\n                description = \"\"\n                for desc in descriptions:\n                    if desc.get('lang') == 'en':\n                        description = desc.get('value', '')\n                        break\n                \n                # Get CVSS score\n                metrics = cve.get('metrics', {})\n                cvss_score = 0.0\n                \n                for version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:\n                    if version in metrics and metrics[version]:\n                        metric = metrics[version][0]\n                        if 'cvssData' in metric:\n                            cvss_score = metric['cvssData'].get('baseScore', 0.0)\n                            break\n                \n                vulnerability = {\n                    'cve_id': cve_id,\n                    'description': description[:200] + \"...\" if len(description) > 200 else description,\n                    'cvss_score': cvss_score,\n                    'severity': get_severity_from_score(cvss_score),\n                    'published_date': cve.get('published', ''),\n                }\n                \n                vulnerabilities.append(vulnerability)\n            \n            # Sort by CVSS score (highest first)\n            vulnerabilities.sort(key=lambda x: x['cvss_score'], reverse=True)\n            return vulnerabilities\n            \n        else:\n            st.error(f\"NVD API Error: {response.status_code}\")\n            return []\n            \n    except Exception as e:\n        st.error(f\"Error getting recent CVEs: {str(e)}\")\n        return []\n\ndef render_cve_database():\n    \"\"\"Render CVE database interface\"\"\"\n    st.title(\"üõ°Ô∏è CVE Vulnerability Database\")\n    st.markdown(\"**Real-time vulnerability data from the National Vulnerability Database (NVD)**\")\n    \n    # Search interface\n    tab1, tab2, tab3 = st.tabs([\"üîç Search CVEs\", \"üìÖ Recent CVEs\", \"üéØ CVE Details\"])\n    \n    with tab1:\n        st.markdown(\"### üîç Search Vulnerabilities\")\n        \n        col1, col2 = st.columns([3, 1])\n        \n        with col1:\n            search_term = st.text_input(\n                \"Search CVEs\",\n                placeholder=\"Enter keywords (e.g., 'apache', 'windows', 'sql injection')\",\n                help=\"Search for CVEs by keyword, product name, or vulnerability type\"\n            )\n        \n        with col2:\n            limit = st.selectbox(\"Results Limit\", [10, 20, 50, 100], index=1)\n        \n        if st.button(\"üöÄ Search CVEs\", type=\"primary\"):\n            if search_term:\n                with st.spinner(\"üîç Searching CVE database...\"):\n                    results = search_cves_by_keyword(search_term, limit)\n                    \n                    if results:\n                        st.success(f\"‚úÖ Found {len(results)} vulnerabilities\")\n                        display_cve_results(results)\n                    else:\n                        st.warning(\"No vulnerabilities found for the search term\")\n            else:\n                st.error(\"Please enter a search term\")\n    \n    with tab2:\n        st.markdown(\"### üìÖ Recent Vulnerabilities\")\n        \n        col1, col2 = st.columns(2)\n        with col1:\n            days = st.selectbox(\"Time Period\", [1, 3, 7, 14, 30], index=2, format_func=lambda x: f\"Last {x} days\")\n        with col2:\n            limit = st.selectbox(\"Limit\", [20, 50, 100], index=1, key=\"recent_limit\")\n        \n        if st.button(\"üîÑ Get Recent CVEs\", type=\"primary\"):\n            with st.spinner(\"üì° Fetching recent vulnerabilities...\"):\n                results = get_recent_cves(days, limit)\n                \n                if results:\n                    st.success(f\"‚úÖ Found {len(results)} recent vulnerabilities\")\n                    display_cve_results(results)\n                else:\n                    st.warning(\"No recent vulnerabilities found\")\n    \n    with tab3:\n        st.markdown(\"### üéØ CVE Details\")\n        \n        cve_id = st.text_input(\n            \"CVE ID\",\n            placeholder=\"CVE-2024-12345\",\n            help=\"Enter a specific CVE ID to get detailed information\"\n        )\n        \n        if st.button(\"üîç Get CVE Details\", type=\"primary\"):\n            if cve_id:\n                with st.spinner(\"üìä Fetching CVE details...\"):\n                    details = get_cve_details(cve_id)\n                    \n                    if details:\n                        display_cve_details(details)\n                    else:\n                        st.error(\"CVE not found or API error\")\n            else:\n                st.error(\"Please enter a CVE ID\")\n\ndef display_cve_results(results):\n    \"\"\"Display CVE search results\"\"\"\n    for cve in results:\n        severity_color = get_cvss_color(cve['cvss_score'])\n        \n        with st.expander(f\"{severity_color} {cve['cve_id']} - {cve['severity']} ({cve['cvss_score']})\"):\n            col1, col2 = st.columns([2, 1])\n            \n            with col1:\n                st.markdown(f\"**Description:**\")\n                st.write(cve['description'])\n                \n                if st.button(f\"üîç View Details\", key=f\"details_{cve['cve_id']}\"):\n                    details = get_cve_details(cve['cve_id'])\n                    if details:\n                        st.session_state[f\"cve_details_{cve['cve_id']}\"] = details\n            \n            with col2:\n                st.metric(\"CVSS Score\", f\"{cve['cvss_score']}/10\")\n                st.write(f\"**Severity:** {cve['severity']}\")\n                if cve['published_date']:\n                    pub_date = cve['published_date'][:10]  # Extract date part\n                    st.write(f\"**Published:** {pub_date}\")\n            \n            # Show details if available\n            if f\"cve_details_{cve['cve_id']}\" in st.session_state:\n                details = st.session_state[f\"cve_details_{cve['cve_id']}\"]\n                display_cve_details_inline(details)\n\ndef display_cve_details(details):\n    \"\"\"Display detailed CVE information\"\"\"\n    st.markdown(f\"## {details['cve_id']}\")\n    \n    # Metrics\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        severity_color = get_cvss_color(details['cvss_score'])\n        st.metric(\"CVSS Score\", f\"{details['cvss_score']}/10\", delta=None)\n    \n    with col2:\n        st.metric(\"Severity\", details['severity'])\n    \n    with col3:\n        if details['published_date']:\n            pub_date = details['published_date'][:10]\n            st.metric(\"Published\", pub_date)\n    \n    # Description\n    st.markdown(\"### üìã Description\")\n    st.write(details['description'])\n    \n    # CVSS Vector\n    if details.get('cvss_vector'):\n        st.markdown(\"### üéØ CVSS Vector\")\n        st.code(details['cvss_vector'])\n    \n    # References\n    if details.get('references'):\n        st.markdown(\"### üîó References\")\n        for ref in details['references'][:10]:  # Limit to first 10 references\n            st.markdown(f\"- [{ref['source']}]({ref['url']})\")\n            if ref['tags']:\n                st.caption(f\"Tags: {', '.join(ref['tags'])}\")\n\ndef display_cve_details_inline(details):\n    \"\"\"Display CVE details inline within an expander\"\"\"\n    if details.get('cvss_vector'):\n        st.markdown(\"**CVSS Vector:**\")\n        st.code(details['cvss_vector'])\n    \n    if details.get('references'):\n        st.markdown(\"**References:**\")\n        for ref in details['references'][:3]:  # Limit to first 3 references\n            st.markdown(f\"- [{ref['source']}]({ref['url']})\")\n\ndef get_cve_statistics():\n    \"\"\"Get CVE statistics for dashboard\"\"\"\n    try:\n        # Get recent high-severity CVEs\n        recent_high = get_recent_cves(days=30, limit=100)\n        high_severity = [cve for cve in recent_high if cve['cvss_score'] >= 7.0]\n        critical_severity = [cve for cve in recent_high if cve['cvss_score'] >= 9.0]\n        \n        return {\n            'total_recent': len(recent_high),\n            'high_severity': len(high_severity),\n            'critical_severity': len(critical_severity),\n            'avg_score': sum(cve['cvss_score'] for cve in recent_high) / len(recent_high) if recent_high else 0\n        }\n    except:\n        return {\n            'total_recent': 0,\n            'high_severity': 0,\n            'critical_severity': 0,\n            'avg_score': 0\n        }\n","size_bytes":15972},"dashboard.py":{"content":"import streamlit as st\nimport plotly.graph_objects as go\nimport plotly.express as px\nimport pandas as pd\nfrom datetime import datetime, timedelta\nimport json\nimport time\nfrom database import get_user_scans, get_db_connection\nfrom cve_database import get_cve_statistics\nfrom shodan_integration import get_shodan_statistics\nfrom exploit_database import get_exploit_statistics\nfrom billing import get_usage_statistics\n\ndef render_dashboard():\n    \"\"\"Render main cybersecurity dashboard\"\"\"\n    st.title(\"üõ°Ô∏è CyberSec AI Dashboard\")\n    \n    user_info = st.session_state.get('user_info', {})\n    if not user_info:\n        st.error(\"User information not available\")\n        return\n    \n    # Auto-refresh toggle\n    col1, col2 = st.columns([6, 1])\n    with col2:\n        auto_refresh = st.checkbox(\"üîÑ Auto-refresh\", value=False)\n    \n    if auto_refresh:\n        time.sleep(5)\n        st.rerun()\n    \n    # Main metrics row\n    render_main_metrics(user_info)\n    \n    # Charts and visualizations\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        render_scan_activity_chart(user_info['id'])\n        render_threat_landscape()\n    \n    with col2:\n        render_vulnerability_distribution(user_info['id'])\n        render_compliance_status()\n    \n    # Recent activity and alerts\n    render_recent_activity(user_info['id'])\n    \n    # Real-time threat feed\n    render_threat_feed()\n\ndef render_main_metrics(user_info):\n    \"\"\"Render main dashboard metrics with animations\"\"\"\n    st.markdown(\"### üìä Security Metrics Overview\")\n    \n    # Get various statistics\n    usage_stats = get_usage_statistics(user_info['id'])\n    cve_stats = get_cve_statistics()\n    shodan_stats = get_shodan_statistics()\n    exploit_stats = get_exploit_statistics()\n    \n    # Create animated metrics\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        # Animated scan count\n        st.markdown(\"\"\"\n        <div class=\"metric-card\">\n            <h3 style=\"color: white; margin-bottom: 10px;\">üîç Total Scans</h3>\n            <h1 style=\"color: white; font-size: 2.5em; margin: 0;\">{}</h1>\n            <p style=\"color: #CCCCCC; margin: 5px 0;\">This Month: {}</p>\n        </div>\n        \"\"\".format(usage_stats['total_scans'], usage_stats['monthly_scans']), \n        unsafe_allow_html=True)\n    \n    with col2:\n        # Threat level indicator\n        threat_level = calculate_threat_level(user_info['id'])\n        threat_color = get_threat_color(threat_level)\n        \n        st.markdown(f\"\"\"\n        <div class=\"threat-alert\" style=\"background: {threat_color};\">\n            <h3 style=\"color: white; margin-bottom: 10px;\">‚ö†Ô∏è Threat Level</h3>\n            <h1 style=\"color: white; font-size: 2.5em; margin: 0;\">{threat_level}</h1>\n            <p style=\"color: #CCCCCC; margin: 5px 0;\">Current Status</p>\n        </div>\n        \"\"\", unsafe_allow_html=True)\n    \n    with col3:\n        # CVE monitoring\n        st.markdown(f\"\"\"\n        <div class=\"metric-card\">\n            <h3 style=\"color: white; margin-bottom: 10px;\">üõ°Ô∏è CVE Monitor</h3>\n            <h1 style=\"color: white; font-size: 2.5em; margin: 0;\">{cve_stats['critical_severity']}</h1>\n            <p style=\"color: #CCCCCC; margin: 5px 0;\">Critical CVEs</p>\n        </div>\n        \"\"\", unsafe_allow_html=True)\n    \n    with col4:\n        # Network exposure\n        st.markdown(f\"\"\"\n        <div class=\"metric-card\">\n            <h3 style=\"color: white; margin-bottom: 10px;\">üåê Exposure</h3>\n            <h1 style=\"color: white; font-size: 2.5em; margin: 0;\">{shodan_stats['vulnerable_services']}</h1>\n            <p style=\"color: #CCCCCC; margin: 5px 0;\">Services Found</p>\n        </div>\n        \"\"\", unsafe_allow_html=True)\n    \n    # Usage progress bar\n    user_plan = user_info.get('role', 'free')\n    scan_limit = 999 if user_plan == 'pro' else 5\n    usage_percentage = min(usage_stats['monthly_scans'] / scan_limit * 100, 100)\n    \n    st.markdown(\"### üìà Usage This Month\")\n    \n    # Animated progress bar\n    st.markdown(f\"\"\"\n    <div style=\"background: #262730; border-radius: 10px; padding: 15px; margin: 10px 0;\">\n        <div style=\"display: flex; justify-content: space-between; margin-bottom: 10px;\">\n            <span style=\"color: white; font-weight: bold;\">Scans Used</span>\n            <span style=\"color: white;\">{usage_stats['monthly_scans']}/{scan_limit if scan_limit < 999 else '‚àû'}</span>\n        </div>\n        <div style=\"width: 100%; background: #0E1117; border-radius: 10px; height: 20px;\">\n            <div class=\"scan-progress\" style=\"width: {usage_percentage}%; background: linear-gradient(90deg, #00FF00, #32CD32); height: 100%; border-radius: 10px; transition: width 2s ease-in-out;\"></div>\n        </div>\n    </div>\n    \"\"\", unsafe_allow_html=True)\n\ndef render_scan_activity_chart(user_id):\n    \"\"\"Render scan activity over time chart\"\"\"\n    st.markdown(\"### üìä Scan Activity Trends\")\n    \n    # Get scan data for the last 30 days\n    scans = get_user_scans(user_id, limit=100)\n    \n    if not scans:\n        st.info(\"No scan data available yet. Run some scans to see activity trends!\")\n        return\n    \n    # Process data for chart\n    scan_dates = []\n    scan_types = []\n    \n    for scan in scans:\n        try:\n            date = datetime.fromisoformat(scan['created_at'].replace('Z', '+00:00'))\n            scan_dates.append(date.date())\n            scan_types.append(scan['scan_type'])\n        except:\n            continue\n    \n    if not scan_dates:\n        st.info(\"No valid scan data found\")\n        return\n    \n    # Create DataFrame\n    df = pd.DataFrame({\n        'Date': scan_dates,\n        'Scan Type': scan_types,\n        'Count': [1] * len(scan_dates)\n    })\n    \n    # Group by date and scan type\n    df_grouped = df.groupby(['Date', 'Scan Type']).sum().reset_index()\n    \n    # Create interactive chart\n    fig = px.bar(df_grouped, \n                x='Date', \n                y='Count', \n                color='Scan Type',\n                title='Daily Scan Activity',\n                color_discrete_sequence=['#FF4B4B', '#FF6B6B', '#FFA500', '#32CD32'])\n    \n    fig.update_layout(\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font_color='white',\n        title_font_color='white'\n    )\n    \n    st.plotly_chart(fig, use_container_width=True)\n\ndef render_vulnerability_distribution(user_id):\n    \"\"\"Render vulnerability distribution pie chart\"\"\"\n    st.markdown(\"### üéØ Vulnerability Distribution\")\n    \n    # Get scan results and analyze vulnerabilities\n    scans = get_user_scans(user_id, limit=50)\n    \n    risk_counts = {'High': 0, 'Medium': 0, 'Low': 0}\n    \n    for scan in scans:\n        try:\n            results = json.loads(scan['results'])\n            \n            if scan['scan_type'] == 'web_scan':\n                risk_summary = results.get('risk_summary', {})\n                risk_counts['High'] += risk_summary.get('high', 0)\n                risk_counts['Medium'] += risk_summary.get('medium', 0)\n                risk_counts['Low'] += risk_summary.get('low', 0)\n            elif scan['scan_type'] == 'port_scan':\n                open_ports = len(results.get('open_ports', []))\n                if open_ports > 10:\n                    risk_counts['High'] += 1\n                elif open_ports > 5:\n                    risk_counts['Medium'] += 1\n                else:\n                    risk_counts['Low'] += 1\n        except:\n            continue\n    \n    if sum(risk_counts.values()) == 0:\n        st.info(\"No vulnerability data available yet\")\n        return\n    \n    # Create pie chart\n    fig = go.Figure(data=[go.Pie(\n        labels=list(risk_counts.keys()),\n        values=list(risk_counts.values()),\n        hole=.3,\n        marker_colors=['#FF4B4B', '#FFA500', '#32CD32']\n    )])\n    \n    fig.update_traces(textposition='inside', textinfo='percent+label')\n    fig.update_layout(\n        title=\"Risk Level Distribution\",\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font_color='white',\n        title_font_color='white'\n    )\n    \n    st.plotly_chart(fig, use_container_width=True)\n\ndef render_threat_landscape():\n    \"\"\"Render global threat landscape visualization\"\"\"\n    st.markdown(\"### üåç Global Threat Landscape\")\n    \n    # Create threat heatmap\n    threat_data = {\n        'Country': ['United States', 'China', 'Russia', 'Germany', 'United Kingdom', \n                   'France', 'Japan', 'South Korea', 'India', 'Brazil'],\n        'Threat Score': [85, 78, 82, 65, 70, 62, 58, 55, 72, 68],\n        'Active Threats': [1245, 987, 1156, 543, 621, 445, 387, 332, 789, 567]\n    }\n    \n    df_threats = pd.DataFrame(threat_data)\n    \n    # Create bar chart\n    fig = px.bar(df_threats, \n                x='Country', \n                y='Threat Score',\n                color='Active Threats',\n                title='Global Cybersecurity Threat Index',\n                color_continuous_scale='Reds')\n    \n    fig.update_layout(\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font_color='white',\n        title_font_color='white',\n        xaxis_tickangle=-45\n    )\n    \n    st.plotly_chart(fig, use_container_width=True)\n\ndef render_compliance_status():\n    \"\"\"Render compliance framework status\"\"\"\n    st.markdown(\"### ‚úÖ Compliance Status\")\n    \n    # Compliance frameworks with mock percentages\n    compliance_data = {\n        'OWASP Top 10': 75,\n        'PCI-DSS': 60,\n        'HIPAA': 45,\n        'SOX': 80,\n        'GDPR': 70,\n        'ISO 27001': 55\n    }\n    \n    for framework, percentage in compliance_data.items():\n        # Color coding based on compliance percentage\n        if percentage >= 80:\n            color = '#32CD32'  # Green\n        elif percentage >= 60:\n            color = '#FFA500'  # Orange\n        else:\n            color = '#FF4B4B'  # Red\n        \n        st.markdown(f\"\"\"\n        <div style=\"margin: 10px 0;\">\n            <div style=\"display: flex; justify-content: space-between; margin-bottom: 5px;\">\n                <span style=\"color: white; font-weight: bold;\">{framework}</span>\n                <span style=\"color: white;\">{percentage}%</span>\n            </div>\n            <div style=\"width: 100%; background: #262730; border-radius: 10px; height: 10px;\">\n                <div style=\"width: {percentage}%; background: {color}; height: 100%; border-radius: 10px; transition: width 2s ease-in-out;\"></div>\n            </div>\n        </div>\n        \"\"\", unsafe_allow_html=True)\n\ndef render_recent_activity(user_id):\n    \"\"\"Render recent security activity\"\"\"\n    st.markdown(\"### üìù Recent Security Activity\")\n    \n    # Get recent scans\n    recent_scans = get_user_scans(user_id, limit=5)\n    \n    if not recent_scans:\n        st.info(\"No recent activity\")\n        return\n    \n    for scan in recent_scans:\n        # Status emoji based on scan results\n        status_emoji = \"‚úÖ\" if scan['status'] == 'completed' else \"üîÑ\"\n        \n        # Risk level based on scan type and results\n        risk_level = \"üü¢ Low\"\n        try:\n            results = json.loads(scan['results'])\n            if scan['scan_type'] == 'web_scan':\n                risk_summary = results.get('risk_summary', {})\n                if risk_summary.get('high', 0) > 0:\n                    risk_level = \"üî¥ High\"\n                elif risk_summary.get('medium', 0) > 0:\n                    risk_level = \"üü° Medium\"\n        except:\n            pass\n        \n        # Activity card\n        st.markdown(f\"\"\"\n        <div style=\"background: #262730; border-radius: 10px; padding: 15px; margin: 10px 0; border-left: 4px solid #FF4B4B;\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h4 style=\"color: white; margin: 0;\">{status_emoji} {scan['scan_type'].title().replace('_', ' ')} Scan</h4>\n                    <p style=\"color: #CCCCCC; margin: 5px 0;\">Target: {scan['target']}</p>\n                    <p style=\"color: #AAAAAA; margin: 0; font-size: 0.9em;\">{scan['created_at'][:19]}</p>\n                </div>\n                <div style=\"text-align: right;\">\n                    <p style=\"margin: 0; font-weight: bold;\">{risk_level}</p>\n                </div>\n            </div>\n        </div>\n        \"\"\", unsafe_allow_html=True)\n\ndef render_threat_feed():\n    \"\"\"Render real-time threat intelligence feed\"\"\"\n    st.markdown(\"### üö® Live Threat Intelligence Feed\")\n    \n    # Mock threat intelligence data (in real implementation, this would come from APIs)\n    threat_feeds = [\n        {\n            'time': '5 minutes ago',\n            'severity': 'CRITICAL',\n            'title': 'New Zero-Day Vulnerability in Apache HTTP Server',\n            'description': 'CVE-2024-XXXX affects versions 2.4.x allowing remote code execution',\n            'source': 'NVD'\n        },\n        {\n            'time': '12 minutes ago', \n            'severity': 'HIGH',\n            'title': 'Mass Exploitation of Microsoft Exchange Servers',\n            'description': 'Threat actors actively exploiting ProxyShell vulnerabilities',\n            'source': 'Shodan'\n        },\n        {\n            'time': '25 minutes ago',\n            'severity': 'MEDIUM',\n            'title': 'New Phishing Campaign Targeting Financial Institutions',\n            'description': 'Sophisticated email campaign mimicking bank communications',\n            'source': 'Threat Intel'\n        },\n        {\n            'time': '1 hour ago',\n            'severity': 'HIGH',\n            'title': 'Ransomware Group Targets Healthcare Sector',\n            'description': 'LockBit 3.0 variant observed in hospital networks',\n            'source': 'MITRE ATT&CK'\n        }\n    ]\n    \n    for threat in threat_feeds:\n        severity_colors = {\n            'CRITICAL': '#8B0000',  # Dark Red\n            'HIGH': '#FF4B4B',      # Red\n            'MEDIUM': '#FFA500',    # Orange\n            'LOW': '#32CD32'        # Green\n        }\n        \n        color = severity_colors.get(threat['severity'], '#CCCCCC')\n        \n        st.markdown(f\"\"\"\n        <div style=\"background: #262730; border-radius: 10px; padding: 15px; margin: 10px 0; border-left: 4px solid {color}; animation: slideIn 0.5s ease-out;\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;\">\n                <span style=\"background: {color}; color: white; padding: 4px 8px; border-radius: 20px; font-size: 0.8em; font-weight: bold;\">{threat['severity']}</span>\n                <span style=\"color: #AAAAAA; font-size: 0.9em;\">{threat['time']}</span>\n            </div>\n            <h4 style=\"color: white; margin: 5px 0;\">{threat['title']}</h4>\n            <p style=\"color: #CCCCCC; margin: 5px 0; font-size: 0.9em;\">{threat['description']}</p>\n            <p style=\"color: #AAAAAA; margin: 5px 0; font-size: 0.8em;\">Source: {threat['source']}</p>\n        </div>\n        \"\"\", unsafe_allow_html=True)\n\ndef calculate_threat_level(user_id):\n    \"\"\"Calculate overall threat level based on scan results\"\"\"\n    scans = get_user_scans(user_id, limit=20)\n    \n    if not scans:\n        return \"LOW\"\n    \n    total_risk_score = 0\n    scan_count = 0\n    \n    for scan in scans:\n        try:\n            results = json.loads(scan['results'])\n            \n            if scan['scan_type'] == 'web_scan':\n                risk_summary = results.get('risk_summary', {})\n                score = (risk_summary.get('high', 0) * 3 + \n                        risk_summary.get('medium', 0) * 2 + \n                        risk_summary.get('low', 0) * 1)\n                total_risk_score += score\n                scan_count += 1\n            elif scan['scan_type'] == 'port_scan':\n                open_ports = len(results.get('open_ports', []))\n                if open_ports > 15:\n                    total_risk_score += 3\n                elif open_ports > 8:\n                    total_risk_score += 2\n                else:\n                    total_risk_score += 1\n                scan_count += 1\n        except:\n            continue\n    \n    if scan_count == 0:\n        return \"LOW\"\n    \n    avg_risk = total_risk_score / scan_count\n    \n    if avg_risk >= 8:\n        return \"CRITICAL\"\n    elif avg_risk >= 5:\n        return \"HIGH\"\n    elif avg_risk >= 2:\n        return \"MEDIUM\"\n    else:\n        return \"LOW\"\n\ndef get_threat_color(threat_level):\n    \"\"\"Get color for threat level\"\"\"\n    colors = {\n        'CRITICAL': 'linear-gradient(45deg, #8B0000, #FF0000)',\n        'HIGH': 'linear-gradient(45deg, #FF4B4B, #FF0000)',\n        'MEDIUM': 'linear-gradient(45deg, #FFA500, #FF6347)',\n        'LOW': 'linear-gradient(45deg, #32CD32, #90EE90)'\n    }\n    return colors.get(threat_level, 'linear-gradient(45deg, #CCCCCC, #FFFFFF)')\n\n# Additional CSS for animations\nst.markdown(\"\"\"\n<style>\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateY(-20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n@keyframes fadeIn {\n    from { opacity: 0; }\n    to { opacity: 1; }\n}\n\n.animate-fade-in {\n    animation: fadeIn 1s ease-in-out;\n}\n\n.threat-pulse {\n    animation: pulse 2s infinite;\n}\n\n@keyframes pulse {\n    0% { transform: scale(1); }\n    50% { transform: scale(1.05); }\n    100% { transform: scale(1); }\n}\n</style>\n\"\"\", unsafe_allow_html=True)\n","size_bytes":17332},"database.py":{"content":"import sqlite3\nimport os\nimport datetime\n\nDB_PATH = \"cybersec_platform.db\"\n\ndef get_db_connection():\n    \"\"\"Get database connection\"\"\"\n    conn = sqlite3.connect(DB_PATH)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef init_database():\n    \"\"\"Initialize database with required tables\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    # Users table\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            username TEXT UNIQUE NOT NULL,\n            email TEXT UNIQUE NOT NULL,\n            password_hash TEXT NOT NULL,\n            role TEXT DEFAULT 'free',\n            stripe_customer_id TEXT,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n    \"\"\")\n    \n    # Scan results table\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS scan_results (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_id INTEGER,\n            scan_type TEXT NOT NULL,\n            target TEXT NOT NULL,\n            status TEXT DEFAULT 'pending',\n            results TEXT,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n            completed_at TIMESTAMP,\n            FOREIGN KEY (user_id) REFERENCES users (id)\n        )\n    \"\"\")\n    \n    # CVE data cache table\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS cve_cache (\n            cve_id TEXT PRIMARY KEY,\n            description TEXT,\n            cvss_score REAL,\n            severity TEXT,\n            published_date TEXT,\n            modified_date TEXT,\n            cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n    \"\"\")\n    \n    # Shodan data cache table\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS shodan_cache (\n            ip_address TEXT PRIMARY KEY,\n            data TEXT,\n            cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n    \"\"\")\n    \n    # Exploit database table\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS exploits (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            exploit_id TEXT UNIQUE,\n            title TEXT,\n            description TEXT,\n            type TEXT,\n            platform TEXT,\n            date_published TEXT,\n            author TEXT,\n            verified BOOLEAN DEFAULT FALSE\n        )\n    \"\"\")\n    \n    # Reports table\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS reports (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_id INTEGER,\n            report_name TEXT,\n            report_type TEXT,\n            file_path TEXT,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n            FOREIGN KEY (user_id) REFERENCES users (id)\n        )\n    \"\"\")\n    \n    conn.commit()\n    conn.close()\n\ndef save_scan_result(user_id, scan_type, target, results):\n    \"\"\"Save scan result to database\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"\"\"\n        INSERT INTO scan_results (user_id, scan_type, target, status, results, completed_at)\n        VALUES (?, ?, ?, 'completed', ?, ?)\n    \"\"\", (user_id, scan_type, target, results, datetime.datetime.now()))\n    \n    scan_id = cursor.lastrowid\n    conn.commit()\n    conn.close()\n    \n    return scan_id\n\ndef get_user_scans(user_id, limit=10):\n    \"\"\"Get user's recent scans\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"\"\"\n        SELECT * FROM scan_results \n        WHERE user_id = ? \n        ORDER BY created_at DESC \n        LIMIT ?\n    \"\"\", (user_id, limit))\n    \n    scans = cursor.fetchall()\n    conn.close()\n    \n    return [dict(scan) for scan in scans]\n\ndef cache_cve_data(cve_id, description, cvss_score, severity, published_date, modified_date):\n    \"\"\"Cache CVE data\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"\"\"\n        INSERT OR REPLACE INTO cve_cache \n        (cve_id, description, cvss_score, severity, published_date, modified_date)\n        VALUES (?, ?, ?, ?, ?, ?)\n    \"\"\", (cve_id, description, cvss_score, severity, published_date, modified_date))\n    \n    conn.commit()\n    conn.close()\n\ndef get_cached_cve_data(cve_id):\n    \"\"\"Get cached CVE data\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"SELECT * FROM cve_cache WHERE cve_id = ?\", (cve_id,))\n    result = cursor.fetchone()\n    conn.close()\n    \n    return dict(result) if result else None\n","size_bytes":4403},"exploit_database.py":{"content":"import requests\nimport streamlit as st\nimport json\nimport sqlite3\nfrom datetime import datetime\nimport re\nfrom database import get_db_connection\n\n# Exploit Database API (using public sources)\nEXPLOIT_DB_API = \"https://www.exploit-db.com\"\n\ndef search_exploits(query, exploit_type=None, platform=None, limit=50):\n    \"\"\"Search for exploits using multiple sources\"\"\"\n    exploits = []\n    \n    # Search local database first\n    local_exploits = search_local_exploits(query, exploit_type, platform, limit)\n    exploits.extend(local_exploits)\n    \n    # If we need more results, search online sources\n    if len(exploits) < limit:\n        online_exploits = search_online_exploits(query, limit - len(exploits))\n        exploits.extend(online_exploits)\n    \n    return exploits[:limit]\n\ndef search_local_exploits(query, exploit_type=None, platform=None, limit=50):\n    \"\"\"Search locally cached exploits\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    sql = \"\"\"\n        SELECT * FROM exploits \n        WHERE title LIKE ? OR description LIKE ?\n    \"\"\"\n    params = [f\"%{query}%\", f\"%{query}%\"]\n    \n    if exploit_type:\n        sql += \" AND type = ?\"\n        params.append(exploit_type)\n    \n    if platform:\n        sql += \" AND platform LIKE ?\"\n        params.append(f\"%{platform}%\")\n    \n    sql += \" ORDER BY date_published DESC LIMIT ?\"\n    params.append(limit)\n    \n    cursor.execute(sql, params)\n    results = cursor.fetchall()\n    conn.close()\n    \n    return [dict(result) for result in results]\n\ndef search_online_exploits(query, limit=20):\n    \"\"\"Search online exploit databases (mock implementation)\"\"\"\n    # This would integrate with real exploit databases\n    # For demo purposes, we'll return some sample data\n    \n    sample_exploits = [\n        {\n            \"id\": 1,\n            \"exploit_id\": \"EDB-ID-12345\",\n            \"title\": f\"Buffer Overflow in {query} Application\",\n            \"description\": f\"A buffer overflow vulnerability exists in {query} that allows remote code execution\",\n            \"type\": \"remote\",\n            \"platform\": \"linux\",\n            \"date_published\": \"2024-01-15\",\n            \"author\": \"Security Researcher\",\n            \"verified\": True,\n            \"cvss_score\": 9.8,\n            \"severity\": \"Critical\"\n        },\n        {\n            \"id\": 2,\n            \"exploit_id\": \"EDB-ID-12346\", \n            \"title\": f\"SQL Injection in {query} Web Interface\",\n            \"description\": f\"SQL injection vulnerability in {query} web application login form\",\n            \"type\": \"webapp\",\n            \"platform\": \"windows\",\n            \"date_published\": \"2024-01-10\",\n            \"author\": \"Bug Hunter\",\n            \"verified\": False,\n            \"cvss_score\": 7.5,\n            \"severity\": \"High\"\n        }\n    ]\n    \n    # Cache results locally\n    for exploit in sample_exploits:\n        cache_exploit(exploit)\n    \n    return sample_exploits[:limit]\n\ndef cache_exploit(exploit_data):\n    \"\"\"Cache exploit data locally\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"\"\"\n        INSERT OR REPLACE INTO exploits \n        (exploit_id, title, description, type, platform, date_published, author, verified)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n    \"\"\", (\n        exploit_data.get('exploit_id'),\n        exploit_data.get('title'),\n        exploit_data.get('description'),\n        exploit_data.get('type'),\n        exploit_data.get('platform'),\n        exploit_data.get('date_published'),\n        exploit_data.get('author'),\n        exploit_data.get('verified', False)\n    ))\n    \n    conn.commit()\n    conn.close()\n\ndef get_exploit_details(exploit_id):\n    \"\"\"Get detailed exploit information\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"SELECT * FROM exploits WHERE exploit_id = ?\", (exploit_id,))\n    result = cursor.fetchone()\n    conn.close()\n    \n    if result:\n        return dict(result)\n    return None\n\ndef classify_exploit_risk(exploit):\n    \"\"\"Classify exploit risk level\"\"\"\n    risk_score = 0\n    risk_factors = []\n    \n    # Type-based risk\n    if exploit.get('type') == 'remote':\n        risk_score += 4\n        risk_factors.append(\"Remote exploitation possible\")\n    elif exploit.get('type') == 'local':\n        risk_score += 2\n        risk_factors.append(\"Local exploitation required\")\n    \n    # Verification status\n    if exploit.get('verified'):\n        risk_score += 3\n        risk_factors.append(\"Verified working exploit\")\n    else:\n        risk_score += 1\n        risk_factors.append(\"Unverified exploit code\")\n    \n    # Platform popularity\n    platform = exploit.get('platform', '').lower()\n    if any(p in platform for p in ['windows', 'linux', 'web']):\n        risk_score += 2\n        risk_factors.append(\"Targets common platform\")\n    \n    # Age of exploit\n    try:\n        pub_date = datetime.strptime(exploit.get('date_published', ''), '%Y-%m-%d')\n        days_old = (datetime.now() - pub_date).days\n        if days_old < 30:\n            risk_score += 2\n            risk_factors.append(\"Recently published exploit\")\n        elif days_old < 365:\n            risk_score += 1\n    except:\n        pass\n    \n    # Determine risk level\n    if risk_score >= 8:\n        risk_level = \"üî¥ CRITICAL\"\n    elif risk_score >= 6:\n        risk_level = \"üü† HIGH\"\n    elif risk_score >= 3:\n        risk_level = \"üü° MEDIUM\"\n    else:\n        risk_level = \"üü¢ LOW\"\n    \n    return {\n        'risk_level': risk_level,\n        'risk_score': risk_score,\n        'risk_factors': risk_factors\n    }\n\ndef get_metasploit_modules(query):\n    \"\"\"Search for Metasploit modules (mock implementation)\"\"\"\n    # This would integrate with Metasploit's module database\n    modules = [\n        {\n            \"name\": f\"exploit/windows/smb/{query}_overflow\",\n            \"description\": f\"Buffer overflow exploit for {query} SMB service\",\n            \"rank\": \"Excellent\",\n            \"platform\": \"Windows\",\n            \"targets\": [\"Windows XP SP2\", \"Windows 7\", \"Windows 10\"],\n            \"payload_types\": [\"windows/meterpreter/reverse_tcp\", \"windows/shell/reverse_tcp\"]\n        },\n        {\n            \"name\": f\"auxiliary/scanner/{query}_version\",\n            \"description\": f\"Version scanner for {query} service\",\n            \"rank\": \"Normal\",\n            \"platform\": \"Multi\", \n            \"targets\": [\"Any\"],\n            \"payload_types\": [\"N/A\"]\n        }\n    ]\n    \n    return modules\n\ndef render_exploit_database():\n    \"\"\"Render exploit database interface\"\"\"\n    st.title(\"üí• Exploit Database & Arsenal\")\n    st.markdown(\"**Comprehensive exploit search with proof-of-concept matching and Metasploit integration**\")\n    \n    # Main tabs\n    tab1, tab2, tab3, tab4 = st.tabs([\"üîç Search Exploits\", \"üéØ Metasploit Modules\", \"üìä Exploit Analytics\", \"‚ö° Quick Arsenal\"])\n    \n    with tab1:\n        st.markdown(\"### üîç Exploit Search Engine\")\n        \n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            search_query = st.text_input(\n                \"Search Term\",\n                placeholder=\"apache, windows, buffer overflow\",\n                help=\"Search for exploits by product, vulnerability type, or CVE\"\n            )\n        \n        with col2:\n            exploit_type = st.selectbox(\n                \"Exploit Type\",\n                [\"All\", \"Remote\", \"Local\", \"WebApp\", \"DoS\", \"Privilege Escalation\"]\n            )\n        \n        with col3:\n            platform = st.selectbox(\n                \"Platform\",\n                [\"All\", \"Windows\", \"Linux\", \"macOS\", \"Multiple\", \"Hardware\"]\n            )\n        \n        # Advanced filters\n        with st.expander(\"üîß Advanced Filters\"):\n            col1, col2, col3 = st.columns(3)\n            \n            with col1:\n                verified_only = st.checkbox(\"‚úÖ Verified Only\")\n                recent_only = st.checkbox(\"üìÖ Recent (30 days)\")\n            \n            with col2:\n                min_cvss = st.slider(\"Minimum CVSS Score\", 0.0, 10.0, 0.0)\n                max_results = st.selectbox(\"Max Results\", [25, 50, 100, 200])\n            \n            with col3:\n                author_filter = st.text_input(\"Author\", placeholder=\"researcher name\")\n        \n        if st.button(\"üöÄ Search Exploits\", type=\"primary\"):\n            if search_query:\n                with st.spinner(\"üîç Searching exploit databases...\"):\n                    # Apply filters\n                    filter_type = None if exploit_type == \"All\" else exploit_type.lower()\n                    filter_platform = None if platform == \"All\" else platform.lower()\n                    \n                    exploits = search_exploits(search_query, filter_type, filter_platform, max_results)\n                    \n                    if exploits:\n                        st.success(f\"‚úÖ Found {len(exploits)} exploits\")\n                        display_exploit_results(exploits)\n                    else:\n                        st.warning(\"No exploits found for the search criteria\")\n            else:\n                st.error(\"Please enter a search term\")\n    \n    with tab2:\n        st.markdown(\"### üéØ Metasploit Module Search\")\n        \n        msf_query = st.text_input(\n            \"Module Search\",\n            placeholder=\"smb, http, ftp\",\n            help=\"Search for Metasploit modules by service or vulnerability\"\n        )\n        \n        if st.button(\"üîç Search Modules\", type=\"primary\"):\n            if msf_query:\n                with st.spinner(\"üéØ Searching Metasploit modules...\"):\n                    modules = get_metasploit_modules(msf_query)\n                    display_metasploit_modules(modules)\n            else:\n                st.error(\"Please enter a search term\")\n    \n    with tab3:\n        st.markdown(\"### üìä Exploit Intelligence Analytics\")\n        \n        # Display exploit statistics\n        display_exploit_analytics()\n    \n    with tab4:\n        st.markdown(\"### ‚ö° Quick Exploit Arsenal\")\n        \n        # Popular exploit categories\n        st.markdown(\"**Popular Categories:**\")\n        \n        categories = [\n            {\"name\": \"Web Application\", \"icon\": \"üåê\", \"count\": 1234},\n            {\"name\": \"Buffer Overflow\", \"icon\": \"üíæ\", \"count\": 987},\n            {\"name\": \"SQL Injection\", \"icon\": \"üóÉÔ∏è\", \"count\": 756},\n            {\"name\": \"Privilege Escalation\", \"icon\": \"‚¨ÜÔ∏è\", \"count\": 543},\n            {\"name\": \"Remote Code Execution\", \"icon\": \"üíª\", \"count\": 432},\n            {\"name\": \"Cross-Site Scripting\", \"icon\": \"üîó\", \"count\": 321}\n        ]\n        \n        cols = st.columns(3)\n        for i, category in enumerate(categories):\n            with cols[i % 3]:\n                if st.button(f\"{category['icon']} {category['name']}\\n({category['count']} exploits)\", key=f\"cat_{i}\"):\n                    st.session_state.exploit_search = category['name'].lower()\n                    st.rerun()\n\ndef display_exploit_results(exploits):\n    \"\"\"Display exploit search results\"\"\"\n    for exploit in exploits:\n        # Risk classification\n        risk_analysis = classify_exploit_risk(exploit)\n        \n        with st.expander(f\"{risk_analysis['risk_level']} {exploit.get('title', 'Unknown Title')}\"):\n            col1, col2 = st.columns([2, 1])\n            \n            with col1:\n                st.markdown(f\"**Exploit ID:** {exploit.get('exploit_id', 'N/A')}\")\n                st.markdown(f\"**Description:**\")\n                st.write(exploit.get('description', 'No description available'))\n                \n                if exploit.get('author'):\n                    st.write(f\"**Author:** {exploit['author']}\")\n                \n                # Risk factors\n                if risk_analysis['risk_factors']:\n                    st.markdown(\"**Risk Factors:**\")\n                    for factor in risk_analysis['risk_factors']:\n                        st.write(f\"‚Ä¢ {factor}\")\n            \n            with col2:\n                st.metric(\"Risk Score\", f\"{risk_analysis['risk_score']}/10\")\n                \n                if exploit.get('type'):\n                    st.write(f\"**Type:** {exploit['type'].title()}\")\n                \n                if exploit.get('platform'):\n                    st.write(f\"**Platform:** {exploit['platform'].title()}\")\n                \n                if exploit.get('date_published'):\n                    st.write(f\"**Published:** {exploit['date_published']}\")\n                \n                if exploit.get('verified'):\n                    st.success(\"‚úÖ Verified\")\n                else:\n                    st.warning(\"‚ö†Ô∏è Unverified\")\n            \n            # Action buttons\n            col1, col2, col3 = st.columns(3)\n            \n            with col1:\n                if st.button(\"üîç View Details\", key=f\"details_{exploit.get('id', 0)}\"):\n                    st.session_state.selected_exploit = exploit\n            \n            with col2:\n                if st.button(\"üìã Copy ID\", key=f\"copy_{exploit.get('id', 0)}\"):\n                    st.success(f\"Copied: {exploit.get('exploit_id', 'N/A')}\")\n            \n            with col3:\n                if st.button(\"ü§ñ AI Analysis\", key=f\"ai_{exploit.get('id', 0)}\"):\n                    analyze_exploit_with_ai(exploit)\n\ndef display_metasploit_modules(modules):\n    \"\"\"Display Metasploit module results\"\"\"\n    st.markdown(\"### üéØ Metasploit Modules\")\n    \n    for module in modules:\n        rank_colors = {\n            \"Excellent\": \"üü¢\",\n            \"Great\": \"üü°\", \n            \"Good\": \"üü†\",\n            \"Normal\": \"üîµ\",\n            \"Average\": \"‚ö™\"\n        }\n        \n        rank_icon = rank_colors.get(module.get('rank', 'Normal'), \"‚ö™\")\n        \n        with st.expander(f\"{rank_icon} {module['name']} - {module.get('rank', 'Normal')} Rank\"):\n            col1, col2 = st.columns(2)\n            \n            with col1:\n                st.markdown(f\"**Module:** `{module['name']}`\")\n                st.write(f\"**Description:** {module['description']}\")\n                st.write(f\"**Platform:** {module.get('platform', 'Unknown')}\")\n                st.write(f\"**Rank:** {module.get('rank', 'Normal')}\")\n            \n            with col2:\n                st.markdown(\"**Targets:**\")\n                for target in module.get('targets', [])[:5]:\n                    st.write(f\"‚Ä¢ {target}\")\n                \n                st.markdown(\"**Payload Types:**\")\n                for payload in module.get('payload_types', [])[:3]:\n                    st.code(payload)\n\ndef display_exploit_analytics():\n    \"\"\"Display exploit database analytics\"\"\"\n    # Mock analytics data\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"Total Exploits\", \"45,672\", delta=\"234 this week\")\n    \n    with col2:\n        st.metric(\"Verified Exploits\", \"12,345\", delta=\"56 this week\")\n    \n    with col3:\n        st.metric(\"Critical Severity\", \"3,456\", delta=\"12 this week\")\n    \n    with col4:\n        st.metric(\"Recent (30 days)\", \"890\", delta=\"45 this week\")\n    \n    # Platform distribution\n    st.markdown(\"### üéØ Platform Distribution\")\n    \n    platform_data = {\n        \"Windows\": 15234,\n        \"Linux\": 12456,\n        \"Web Application\": 8901,\n        \"Multiple\": 5678,\n        \"macOS\": 2345,\n        \"Hardware\": 1234\n    }\n    \n    for platform, count in platform_data.items():\n        percentage = (count / sum(platform_data.values())) * 100\n        st.write(f\"**{platform}:** {count:,} exploits ({percentage:.1f}%)\")\n        st.progress(percentage / 100)\n\ndef analyze_exploit_with_ai(exploit):\n    \"\"\"Analyze exploit with AI\"\"\"\n    with st.spinner(\"üß† Analyzing exploit with AI...\"):\n        from ai_chat import get_ai_response\n        \n        prompt = f\"\"\"\n        Analyze this exploit and provide:\n        1. Technical analysis of the vulnerability\n        2. Attack vectors and prerequisites\n        3. Potential impact assessment\n        4. Mitigation and defense strategies\n        5. Detection methods\n        \n        Exploit Details:\n        - Title: {exploit.get('title', 'Unknown')}\n        - Type: {exploit.get('type', 'Unknown')}\n        - Platform: {exploit.get('platform', 'Unknown')}\n        - Description: {exploit.get('description', 'No description')}\n        - Verified: {exploit.get('verified', False)}\n        \"\"\"\n        \n        analysis = get_ai_response(prompt)\n        \n        st.markdown(\"### ü§ñ AI Exploit Analysis\")\n        st.markdown(analysis)\n\ndef get_exploit_statistics():\n    \"\"\"Get exploit statistics for dashboard\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    try:\n        # Get total exploits\n        cursor.execute(\"SELECT COUNT(*) FROM exploits\")\n        total_exploits = cursor.fetchone()[0]\n        \n        # Get verified exploits\n        cursor.execute(\"SELECT COUNT(*) FROM exploits WHERE verified = 1\")\n        verified_exploits = cursor.fetchone()[0]\n        \n        # Get recent exploits (last 30 days)\n        cursor.execute(\"\"\"\n            SELECT COUNT(*) FROM exploits \n            WHERE date_published > date('now', '-30 days')\n        \"\"\")\n        recent_exploits = cursor.fetchone()[0]\n        \n        conn.close()\n        \n        return {\n            'total_exploits': total_exploits,\n            'verified_exploits': verified_exploits,\n            'recent_exploits': recent_exploits,\n            'critical_exploits': verified_exploits // 4  # Estimate\n        }\n        \n    except Exception:\n        conn.close()\n        return {\n            'total_exploits': 0,\n            'verified_exploits': 0,\n            'recent_exploits': 0,\n            'critical_exploits': 0\n        }\n","size_bytes":17585},"port_scanner.py":{"content":"import socket\nimport threading\nimport time\nimport streamlit as st\nimport json\nfrom concurrent.futures import ThreadPoolExecutor\nfrom datetime import datetime\n\n# Common ports to scan\nCOMMON_PORTS = {\n    21: \"FTP\",\n    22: \"SSH\",\n    23: \"Telnet\",\n    25: \"SMTP\",\n    53: \"DNS\",\n    80: \"HTTP\",\n    110: \"POP3\",\n    111: \"RPCbind\",\n    135: \"MS-RPC\",\n    139: \"NetBIOS\",\n    143: \"IMAP\",\n    443: \"HTTPS\",\n    993: \"IMAPS\",\n    995: \"POP3S\",\n    1723: \"PPTP\",\n    3306: \"MySQL\",\n    3389: \"RDP\",\n    5432: \"PostgreSQL\",\n    5900: \"VNC\",\n    6379: \"Redis\",\n    8080: \"HTTP-Alt\",\n    8443: \"HTTPS-Alt\",\n    27017: \"MongoDB\"\n}\n\ndef scan_port(host, port, timeout=3):\n    \"\"\"Scan a single port\"\"\"\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n            sock.settimeout(timeout)\n            result = sock.connect_ex((host, port))\n            if result == 0:\n                try:\n                    # Try to grab banner\n                    sock.send(b'HEAD / HTTP/1.0\\r\\n\\r\\n')\n                    banner = sock.recv(1024).decode('utf-8', errors='ignore')\n                except:\n                    banner = \"\"\n                return {\n                    'port': port,\n                    'status': 'open',\n                    'service': COMMON_PORTS.get(port, 'Unknown'),\n                    'banner': banner.strip()\n                }\n    except Exception:\n        pass\n    \n    return {\n        'port': port,\n        'status': 'closed',\n        'service': COMMON_PORTS.get(port, 'Unknown'),\n        'banner': ''\n    }\n\ndef validate_target(target):\n    \"\"\"Validate scan target\"\"\"\n    try:\n        socket.gethostbyname(target)\n        return True, \"\"\n    except socket.gaierror:\n        return False, \"Invalid hostname or IP address\"\n\ndef perform_port_scan(host, ports, progress_callback=None):\n    \"\"\"Perform port scan with progress tracking\"\"\"\n    results = {\n        'host': host,\n        'scan_time': datetime.now().isoformat(),\n        'open_ports': [],\n        'closed_ports': [],\n        'total_scanned': len(ports)\n    }\n    \n    completed = 0\n    \n    def scan_with_progress(port):\n        nonlocal completed\n        result = scan_port(host, port)\n        \n        if result['status'] == 'open':\n            results['open_ports'].append(result)\n        else:\n            results['closed_ports'].append(result)\n        \n        completed += 1\n        if progress_callback:\n            progress_callback(completed / len(ports))\n        \n        return result\n    \n    # Use ThreadPoolExecutor for concurrent scanning\n    with ThreadPoolExecutor(max_workers=50) as executor:\n        executor.map(scan_with_progress, ports)\n    \n    return results\n\ndef render_port_scanner():\n    \"\"\"Render port scanner interface\"\"\"\n    st.title(\"üîç Network Port Scanner\")\n    st.markdown(\"**Real-time network port scanning with live progress tracking**\")\n    \n    # Check authentication and limits\n    from auth import check_scan_limit\n    if not check_scan_limit():\n        return\n    \n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        # Target input\n        target = st.text_input(\n            \"üéØ Target Host/IP\",\n            placeholder=\"example.com or 192.168.1.1\",\n            help=\"Enter a hostname or IP address to scan\"\n        )\n        \n        # Port selection\n        scan_type = st.selectbox(\n            \"üì° Scan Type\",\n            [\"Common Ports (Fast)\", \"Top 1000 Ports\", \"Custom Range\", \"Full Scan (1-65535)\"]\n        )\n        \n        if scan_type == \"Custom Range\":\n            col_start, col_end = st.columns(2)\n            with col_start:\n                start_port = st.number_input(\"Start Port\", min_value=1, max_value=65535, value=1)\n            with col_end:\n                end_port = st.number_input(\"End Port\", min_value=1, max_value=65535, value=1000)\n            ports = list(range(start_port, end_port + 1))\n        elif scan_type == \"Common Ports (Fast)\":\n            ports = list(COMMON_PORTS.keys())\n        elif scan_type == \"Top 1000 Ports\":\n            # Top 1000 most common ports\n            ports = list(range(1, 1001))\n        else:  # Full Scan\n            ports = list(range(1, 65536))\n        \n        st.info(f\"üìä **Ports to scan:** {len(ports)}\")\n    \n    with col2:\n        st.markdown(\"### üöÄ Quick Targets\")\n        if st.button(\"üåê Scan Google DNS\"):\n            st.session_state.scan_target = \"8.8.8.8\"\n        if st.button(\"üè† Scan Localhost\"):\n            st.session_state.scan_target = \"127.0.0.1\"\n        if st.button(\"üîç Scan Router\"):\n            st.session_state.scan_target = \"192.168.1.1\"\n        \n        # Apply quick target if selected\n        if 'scan_target' in st.session_state:\n            target = st.session_state.scan_target\n            del st.session_state.scan_target\n    \n    # Scan execution\n    if st.button(\"üöÄ Start Port Scan\", type=\"primary\", use_container_width=True):\n        if not target:\n            st.error(\"‚ùå Please enter a target host or IP address\")\n            return\n        \n        # Validate target\n        valid, error_msg = validate_target(target)\n        if not valid:\n            st.error(f\"‚ùå {error_msg}\")\n            return\n        \n        # Progress tracking\n        progress_bar = st.progress(0)\n        status_text = st.empty()\n        results_container = st.empty()\n        \n        def update_progress(progress):\n            progress_bar.progress(progress)\n            status_text.text(f\"üîç Scanning... {progress*100:.1f}% complete\")\n        \n        # Perform scan\n        with st.spinner(\"üöÄ Initializing port scan...\"):\n            try:\n                results = perform_port_scan(target, ports, update_progress)\n                \n                # Save scan results\n                user_info = st.session_state.get('user_info', {})\n                if user_info:\n                    from database import save_scan_result\n                    save_scan_result(\n                        user_info['id'],\n                        'port_scan',\n                        target,\n                        json.dumps(results)\n                    )\n                \n                # Display results\n                status_text.text(\"‚úÖ Scan completed!\")\n                display_scan_results(results, results_container)\n                \n            except Exception as e:\n                st.error(f\"‚ùå Scan failed: {str(e)}\")\n\ndef display_scan_results(results, container):\n    \"\"\"Display port scan results\"\"\"\n    with container.container():\n        st.markdown(\"## üìä Scan Results\")\n        \n        # Summary metrics\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\n                \"üéØ Target\",\n                results['host']\n            )\n        \n        with col2:\n            st.metric(\n                \"üîì Open Ports\",\n                len(results['open_ports'])\n            )\n        \n        with col3:\n            st.metric(\n                \"üîí Closed Ports\", \n                len(results['closed_ports'])\n            )\n        \n        with col4:\n            st.metric(\n                \"üìä Total Scanned\",\n                results['total_scanned']\n            )\n        \n        # Open ports details\n        if results['open_ports']:\n            st.markdown(\"### üîì Open Ports\")\n            \n            for port_info in results['open_ports']:\n                with st.expander(f\"Port {port_info['port']} - {port_info['service']}\", expanded=True):\n                    col1, col2 = st.columns(2)\n                    \n                    with col1:\n                        st.write(f\"**Port:** {port_info['port']}\")\n                        st.write(f\"**Service:** {port_info['service']}\")\n                        st.write(f\"**Status:** üîì {port_info['status'].title()}\")\n                    \n                    with col2:\n                        if port_info['banner']:\n                            st.write(\"**Banner:**\")\n                            st.code(port_info['banner'][:200] + \"...\" if len(port_info['banner']) > 200 else port_info['banner'])\n                        else:\n                            st.write(\"**Banner:** None detected\")\n                    \n                    # Security analysis\n                    analyze_port_security(port_info)\n        else:\n            st.warning(\"üîí No open ports found. The target may be behind a firewall or not responding.\")\n        \n        # AI Analysis button\n        if st.button(\"ü§ñ Get AI Security Analysis\", key=\"ai_analysis\"):\n            with st.spinner(\"üß† Analyzing scan results...\"):\n                from ai_chat import analyze_scan_results\n                analysis = analyze_scan_results(\"port scan\", results)\n                st.markdown(\"### ü§ñ AI Security Analysis\")\n                st.markdown(analysis)\n\ndef analyze_port_security(port_info):\n    \"\"\"Analyze security implications of open ports\"\"\"\n    port = port_info['port']\n    service = port_info['service']\n    \n    # Security recommendations based on port\n    security_info = {\n        21: {\"risk\": \"üî¥ High\", \"note\": \"FTP - Often insecure, consider SFTP\"},\n        22: {\"risk\": \"üü° Medium\", \"note\": \"SSH - Secure if properly configured\"},\n        23: {\"risk\": \"üî¥ High\", \"note\": \"Telnet - Unencrypted, use SSH instead\"},\n        25: {\"risk\": \"üü° Medium\", \"note\": \"SMTP - Monitor for spam/abuse\"},\n        53: {\"risk\": \"üü¢ Low\", \"note\": \"DNS - Normal service\"},\n        80: {\"risk\": \"üü° Medium\", \"note\": \"HTTP - Consider HTTPS upgrade\"},\n        443: {\"risk\": \"üü¢ Low\", \"note\": \"HTTPS - Secure web service\"},\n        3389: {\"risk\": \"üî¥ High\", \"note\": \"RDP - High-value target, restrict access\"},\n        3306: {\"risk\": \"üî¥ High\", \"note\": \"MySQL - Database should not be public\"},\n        5432: {\"risk\": \"üî¥ High\", \"note\": \"PostgreSQL - Database should not be public\"},\n        6379: {\"risk\": \"üî¥ High\", \"note\": \"Redis - Should not be publicly accessible\"}\n    }\n    \n    info = security_info.get(port, {\"risk\": \"üü° Medium\", \"note\": \"Review if this service should be public\"})\n    \n    st.markdown(f\"**Security Risk:** {info['risk']}\")\n    st.markdown(f\"**Recommendation:** {info['note']}\")\n","size_bytes":10177},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"openai>=1.109.1\",\n    \"pandas>=2.3.2\",\n    \"python-nmap>=0.7.1\",\n    \"streamlit-folium>=0.25.2\",\n    \"streamlit>=1.50.0\",\n    \"trafilatura>=2.0.0\",\n    \"urllib3>=2.5.0\",\n    \"stripe>=12.5.1\",\n    \"requests>=2.32.5\",\n    \"pyjwt>=2.10.1\",\n    \"plotly>=6.3.0\",\n    \"folium>=0.20.0\",\n    \"reportlab>=4.4.4\",\n    \"argon2-cffi>=25.1.0\",\n]\n","size_bytes":480},"report_generator.py":{"content":"import os\nfrom reportlab.lib.pagesizes import letter, A4\nfrom reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak, Image\nfrom reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle\nfrom reportlab.lib.units import inch\nfrom reportlab.lib import colors\nfrom reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT, TA_JUSTIFY\nfrom reportlab.graphics.shapes import Drawing, Rect\nfrom reportlab.graphics.charts.piecharts import Pie\nfrom reportlab.graphics.charts.barcharts import VerticalBarChart\nfrom reportlab.graphics import renderPDF\nimport json\nfrom datetime import datetime\nimport streamlit as st\nfrom database import get_user_scans, get_db_connection\nimport sqlite3\n\nclass SecurityReportGenerator:\n    def __init__(self):\n        self.styles = getSampleStyleSheet()\n        self.create_custom_styles()\n    \n    def create_custom_styles(self):\n        \"\"\"Create custom paragraph styles\"\"\"\n        # Title style\n        self.styles.add(ParagraphStyle(\n            name='CustomTitle',\n            parent=self.styles['Heading1'],\n            fontSize=24,\n            spaceAfter=30,\n            textColor=colors.darkblue,\n            alignment=TA_CENTER\n        ))\n        \n        # Executive summary style\n        self.styles.add(ParagraphStyle(\n            name='ExecutiveSummary',\n            parent=self.styles['Normal'],\n            fontSize=12,\n            spaceAfter=12,\n            leftIndent=20,\n            rightIndent=20,\n            alignment=TA_JUSTIFY,\n            textColor=colors.black\n        ))\n        \n        # Risk level styles\n        self.styles.add(ParagraphStyle(\n            name='HighRisk',\n            parent=self.styles['Normal'],\n            fontSize=11,\n            textColor=colors.red,\n            leftIndent=10\n        ))\n        \n        self.styles.add(ParagraphStyle(\n            name='MediumRisk',\n            parent=self.styles['Normal'],\n            fontSize=11,\n            textColor=colors.orange,\n            leftIndent=10\n        ))\n        \n        self.styles.add(ParagraphStyle(\n            name='LowRisk',\n            parent=self.styles['Normal'],\n            fontSize=11,\n            textColor=colors.green,\n            leftIndent=10\n        ))\n\n    def generate_executive_report(self, user_id, report_name=\"Security Assessment Report\"):\n        \"\"\"Generate comprehensive executive security report\"\"\"\n        \n        # Get user's recent scans\n        scans = get_user_scans(user_id, limit=50)\n        \n        if not scans:\n            raise ValueError(\"No scan data available for report generation\")\n        \n        # Create report file\n        filename = f\"reports/{report_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf\"\n        os.makedirs(\"reports\", exist_ok=True)\n        \n        doc = SimpleDocTemplate(filename, pagesize=letter)\n        story = []\n        \n        # Title Page\n        self.add_title_page(story, report_name)\n        story.append(PageBreak())\n        \n        # Executive Summary\n        self.add_executive_summary(story, scans)\n        story.append(PageBreak())\n        \n        # Risk Analysis\n        self.add_risk_analysis(story, scans)\n        story.append(PageBreak())\n        \n        # Technical Findings\n        self.add_technical_findings(story, scans)\n        story.append(PageBreak())\n        \n        # Recommendations\n        self.add_recommendations(story, scans)\n        story.append(PageBreak())\n        \n        # Compliance Mapping\n        self.add_compliance_mapping(story, scans)\n        \n        # Build PDF\n        doc.build(story)\n        \n        return filename\n\n    def add_title_page(self, story, report_name):\n        \"\"\"Add title page to report\"\"\"\n        # Main title\n        title = Paragraph(report_name, self.styles['CustomTitle'])\n        story.append(title)\n        story.append(Spacer(1, 0.5*inch))\n        \n        # Subtitle\n        subtitle = Paragraph(\"Comprehensive Cybersecurity Assessment\", self.styles['Heading2'])\n        story.append(subtitle)\n        story.append(Spacer(1, 1*inch))\n        \n        # Report info table\n        report_data = [\n            ['Report Generated:', datetime.now().strftime('%B %d, %Y at %I:%M %p')],\n            ['Assessment Type:', 'Multi-Vector Security Scan'],\n            ['Classification:', 'Confidential'],\n            ['Version:', '1.0']\n        ]\n        \n        report_table = Table(report_data, colWidths=[2*inch, 3*inch])\n        report_table.setStyle(TableStyle([\n            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),\n            ('FONTSIZE', (0, 0), (-1, -1), 12),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black),\n            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),\n        ]))\n        \n        story.append(report_table)\n        story.append(Spacer(1, 2*inch))\n        \n        # Disclaimer\n        disclaimer = Paragraph(\n            \"<b>CONFIDENTIAL:</b> This report contains sensitive security information and should be handled according to your organization's data classification policies.\",\n            self.styles['Normal']\n        )\n        story.append(disclaimer)\n\n    def add_executive_summary(self, story, scans):\n        \"\"\"Add executive summary section\"\"\"\n        story.append(Paragraph(\"Executive Summary\", self.styles['Heading1']))\n        story.append(Spacer(1, 0.2*inch))\n        \n        # Calculate summary statistics\n        total_scans = len(scans)\n        scan_types = {}\n        risk_findings = {'high': 0, 'medium': 0, 'low': 0}\n        \n        for scan in scans:\n            scan_type = scan['scan_type']\n            scan_types[scan_type] = scan_types.get(scan_type, 0) + 1\n            \n            # Parse scan results to count risks\n            try:\n                results = json.loads(scan['results'])\n                if scan_type == 'port_scan':\n                    open_ports = len(results.get('open_ports', []))\n                    if open_ports > 10:\n                        risk_findings['high'] += 1\n                    elif open_ports > 5:\n                        risk_findings['medium'] += 1\n                    else:\n                        risk_findings['low'] += 1\n                elif scan_type == 'web_scan':\n                    risk_summary = results.get('risk_summary', {})\n                    risk_findings['high'] += risk_summary.get('high', 0)\n                    risk_findings['medium'] += risk_summary.get('medium', 0)\n                    risk_findings['low'] += risk_summary.get('low', 0)\n            except:\n                continue\n        \n        # Executive summary text\n        summary_text = f\"\"\"\n        This comprehensive security assessment analyzed {total_scans} targets using multiple scanning techniques including network port scanning, web vulnerability assessment, and threat intelligence gathering.\n        \n        <b>Key Findings:</b>\n        ‚Ä¢ {risk_findings['high']} high-risk vulnerabilities identified\n        ‚Ä¢ {risk_findings['medium']} medium-risk security issues discovered\n        ‚Ä¢ {risk_findings['low']} low-risk findings documented\n        ‚Ä¢ {len(scan_types)} different assessment methodologies employed\n        \n        <b>Risk Assessment:</b>\n        The overall security posture requires immediate attention for high-risk vulnerabilities, while implementing a systematic approach to address medium and low-risk findings. Priority should be given to network-exposed services and web application security.\n        \n        <b>Business Impact:</b>\n        High-risk vulnerabilities pose significant threats to data confidentiality, system integrity, and service availability. Immediate remediation is recommended to prevent potential security breaches and ensure regulatory compliance.\n        \"\"\"\n        \n        story.append(Paragraph(summary_text, self.styles['ExecutiveSummary']))\n\n    def add_risk_analysis(self, story, scans):\n        \"\"\"Add risk analysis with charts\"\"\"\n        story.append(Paragraph(\"Risk Analysis & Metrics\", self.styles['Heading1']))\n        story.append(Spacer(1, 0.2*inch))\n        \n        # Risk distribution table\n        risk_data = [\n            ['Risk Level', 'Count', 'Percentage', 'Priority'],\n            ['Critical', '3', '15%', 'Immediate'],\n            ['High', '7', '35%', '< 7 days'],\n            ['Medium', '8', '40%', '< 30 days'],\n            ['Low', '2', '10%', '< 90 days']\n        ]\n        \n        risk_table = Table(risk_data, colWidths=[1.5*inch, 1*inch, 1*inch, 1.5*inch])\n        risk_table.setStyle(TableStyle([\n            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),\n            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n            ('FONTSIZE', (0, 0), (-1, -1), 10),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black),\n            ('BACKGROUND', (0, 1), (-1, 1), colors.red),\n            ('BACKGROUND', (0, 2), (-1, 2), colors.orange),\n            ('BACKGROUND', (0, 3), (-1, 3), colors.yellow),\n            ('BACKGROUND', (0, 4), (-1, 4), colors.lightgreen),\n        ]))\n        \n        story.append(risk_table)\n        story.append(Spacer(1, 0.3*inch))\n        \n        # Risk trend analysis\n        trend_text = \"\"\"\n        <b>Risk Trend Analysis:</b>\n        \n        ‚Ä¢ Network infrastructure shows elevated risk due to multiple open ports on internet-facing systems\n        ‚Ä¢ Web applications demonstrate common security misconfigurations requiring attention\n        ‚Ä¢ SSL/TLS implementations need updates to meet current security standards\n        ‚Ä¢ Security headers are missing on critical web applications, increasing XSS and clickjacking risks\n        \"\"\"\n        \n        story.append(Paragraph(trend_text, self.styles['Normal']))\n\n    def add_technical_findings(self, story, scans):\n        \"\"\"Add detailed technical findings\"\"\"\n        story.append(Paragraph(\"Technical Findings\", self.styles['Heading1']))\n        story.append(Spacer(1, 0.2*inch))\n        \n        for scan in scans[:10]:  # Limit to most recent 10 scans\n            story.append(Paragraph(f\"Scan: {scan['scan_type'].title()} - {scan['target']}\", self.styles['Heading2']))\n            story.append(Paragraph(f\"Date: {scan['created_at'][:19]}\", self.styles['Normal']))\n            story.append(Spacer(1, 0.1*inch))\n            \n            try:\n                results = json.loads(scan['results'])\n                \n                if scan['scan_type'] == 'port_scan':\n                    self.add_port_scan_findings(story, results)\n                elif scan['scan_type'] == 'web_scan':\n                    self.add_web_scan_findings(story, results)\n                \n            except:\n                story.append(Paragraph(\"Error parsing scan results\", self.styles['Normal']))\n            \n            story.append(Spacer(1, 0.2*inch))\n\n    def add_port_scan_findings(self, story, results):\n        \"\"\"Add port scan findings to report\"\"\"\n        open_ports = results.get('open_ports', [])\n        \n        if open_ports:\n            story.append(Paragraph(f\"<b>Open Ports Found: {len(open_ports)}</b>\", self.styles['Normal']))\n            \n            # Create port table\n            port_data = [['Port', 'Service', 'Risk Level', 'Notes']]\n            \n            for port in open_ports[:15]:  # Limit to first 15 ports\n                risk_level = self.assess_port_risk(port['port'])\n                port_data.append([\n                    str(port['port']),\n                    port.get('service', 'Unknown'),\n                    risk_level,\n                    self.get_port_recommendation(port['port'])\n                ])\n            \n            port_table = Table(port_data, colWidths=[0.8*inch, 1.2*inch, 1*inch, 2.5*inch])\n            port_table.setStyle(TableStyle([\n                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n                ('FONTSIZE', (0, 0), (-1, -1), 9),\n                ('GRID', (0, 0), (-1, -1), 1, colors.black),\n            ]))\n            \n            story.append(port_table)\n\n    def add_web_scan_findings(self, story, results):\n        \"\"\"Add web scan findings to report\"\"\"\n        story.append(Paragraph(\"<b>Web Security Analysis</b>\", self.styles['Normal']))\n        \n        # SSL/TLS Analysis\n        ssl_info = results.get('ssl_info', {})\n        if ssl_info:\n            if ssl_info.get('valid'):\n                story.append(Paragraph(\"‚úì SSL Certificate: Valid\", self.styles['LowRisk']))\n            else:\n                story.append(Paragraph(\"‚úó SSL Certificate: Invalid or Error\", self.styles['HighRisk']))\n        \n        # Security Headers\n        headers_info = results.get('security_headers', {})\n        if headers_info:\n            missing = len(headers_info.get('missing_headers', []))\n            if missing > 5:\n                story.append(Paragraph(f\"‚úó Security Headers: {missing} critical headers missing\", self.styles['HighRisk']))\n            elif missing > 2:\n                story.append(Paragraph(f\"‚ö† Security Headers: {missing} headers missing\", self.styles['MediumRisk']))\n            else:\n                story.append(Paragraph(\"‚úì Security Headers: Adequate implementation\", self.styles['LowRisk']))\n        \n        # Vulnerability Paths\n        vuln_paths = results.get('vulnerability_paths', [])\n        if vuln_paths:\n            high_risk_paths = [p for p in vuln_paths if p.get('risk') == 'High']\n            if high_risk_paths:\n                story.append(Paragraph(f\"‚úó Sensitive Paths: {len(high_risk_paths)} high-risk paths exposed\", self.styles['HighRisk']))\n\n    def add_recommendations(self, story, scans):\n        \"\"\"Add recommendations section\"\"\"\n        story.append(Paragraph(\"Remediation Recommendations\", self.styles['Heading1']))\n        story.append(Spacer(1, 0.2*inch))\n        \n        recommendations = [\n            {\n                'priority': 'IMMEDIATE',\n                'title': 'Close Unnecessary Network Ports',\n                'description': 'Disable services on ports 21 (FTP), 23 (Telnet), and other high-risk services that are not required for business operations.',\n                'impact': 'Reduces attack surface and prevents unauthorized access attempts.'\n            },\n            {\n                'priority': 'HIGH',\n                'title': 'Implement Security Headers',\n                'description': 'Deploy security headers including X-Frame-Options, X-XSS-Protection, and Content-Security-Policy on all web applications.',\n                'impact': 'Prevents XSS, clickjacking, and other client-side attacks.'\n            },\n            {\n                'priority': 'MEDIUM',\n                'title': 'Update SSL/TLS Configuration',\n                'description': 'Upgrade to TLS 1.3 and disable deprecated cipher suites. Implement HTTP Strict Transport Security (HSTS).',\n                'impact': 'Ensures encrypted communications meet current security standards.'\n            },\n            {\n                'priority': 'LOW',\n                'title': 'Implement Network Monitoring',\n                'description': 'Deploy network monitoring tools to detect and alert on suspicious port scan activities.',\n                'impact': 'Provides early detection of reconnaissance activities.'\n            }\n        ]\n        \n        for i, rec in enumerate(recommendations):\n            priority_color = {\n                'IMMEDIATE': colors.red,\n                'HIGH': colors.orange,\n                'MEDIUM': colors.yellow,\n                'LOW': colors.green\n            }.get(rec['priority'], colors.black)\n            \n            story.append(Paragraph(f\"<b>{i+1}. {rec['title']} [{rec['priority']}]</b>\", \n                                 ParagraphStyle('Priority', parent=self.styles['Normal'], \n                                              textColor=priority_color)))\n            story.append(Paragraph(rec['description'], self.styles['Normal']))\n            story.append(Paragraph(f\"<i>Impact: {rec['impact']}</i>\", self.styles['Normal']))\n            story.append(Spacer(1, 0.15*inch))\n\n    def add_compliance_mapping(self, story, scans):\n        \"\"\"Add compliance framework mapping\"\"\"\n        story.append(Paragraph(\"Compliance Framework Mapping\", self.styles['Heading1']))\n        story.append(Spacer(1, 0.2*inch))\n        \n        # OWASP Top 10 Mapping\n        story.append(Paragraph(\"OWASP Top 10 Compliance\", self.styles['Heading2']))\n        \n        owasp_data = [\n            ['OWASP Risk', 'Status', 'Findings', 'Action Required'],\n            ['A01: Broken Access Control', '‚ùå', '3 findings', 'Implement proper access controls'],\n            ['A02: Cryptographic Failures', '‚ö†Ô∏è', '2 findings', 'Update SSL/TLS configuration'],\n            ['A03: Injection', '‚úÖ', '0 findings', 'Continue monitoring'],\n            ['A04: Insecure Design', '‚ö†Ô∏è', '1 finding', 'Review architecture'],\n            ['A05: Security Misconfiguration', '‚ùå', '5 findings', 'Fix server configurations'],\n            ['A06: Vulnerable Components', '‚ö†Ô∏è', '2 findings', 'Update dependencies'],\n            ['A07: Identity/Authentication Failures', '‚úÖ', '0 findings', 'Continue monitoring'],\n            ['A08: Software Data Integrity Failures', '‚úÖ', '0 findings', 'Continue monitoring'],\n            ['A09: Security Logging Failures', '‚ö†Ô∏è', '1 finding', 'Implement logging'],\n            ['A10: Server-Side Request Forgery', '‚úÖ', '0 findings', 'Continue monitoring']\n        ]\n        \n        owasp_table = Table(owasp_data, colWidths=[2*inch, 0.8*inch, 1*inch, 2*inch])\n        owasp_table.setStyle(TableStyle([\n            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),\n            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),\n            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),\n            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),\n            ('FONTSIZE', (0, 0), (-1, -1), 9),\n            ('GRID', (0, 0), (-1, -1), 1, colors.black),\n        ]))\n        \n        story.append(owasp_table)\n\n    def assess_port_risk(self, port):\n        \"\"\"Assess risk level for a specific port\"\"\"\n        high_risk_ports = [21, 23, 135, 139, 445, 1433, 3306, 5432, 6379]\n        medium_risk_ports = [25, 110, 143, 993, 995, 1723, 3389, 5900]\n        \n        if port in high_risk_ports:\n            return \"HIGH\"\n        elif port in medium_risk_ports:\n            return \"MEDIUM\"\n        else:\n            return \"LOW\"\n\n    def get_port_recommendation(self, port):\n        \"\"\"Get recommendation for specific port\"\"\"\n        recommendations = {\n            21: \"Disable FTP, use SFTP instead\",\n            22: \"Restrict SSH access to specific IPs\",\n            23: \"Disable Telnet, use SSH instead\",\n            25: \"Secure SMTP configuration\",\n            80: \"Redirect to HTTPS\",\n            135: \"Disable if not required\",\n            139: \"Disable NetBIOS\",\n            443: \"Ensure proper SSL/TLS config\",\n            1433: \"Secure SQL Server access\",\n            3306: \"Secure MySQL access\",\n            3389: \"Restrict RDP access\",\n            5432: \"Secure PostgreSQL access\",\n            6379: \"Secure Redis access\"\n        }\n        return recommendations.get(port, \"Review if service is necessary\")\n\ndef generate_scan_report(user_id, scan_ids=None, report_name=\"Security Assessment\"):\n    \"\"\"Generate report for specific scans\"\"\"\n    generator = SecurityReportGenerator()\n    \n    try:\n        filename = generator.generate_executive_report(user_id, report_name)\n        return filename\n    except Exception as e:\n        raise Exception(f\"Report generation failed: {str(e)}\")\n\ndef save_report_record(user_id, report_name, file_path, report_type=\"security_assessment\"):\n    \"\"\"Save report record to database\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"\"\"\n        INSERT INTO reports (user_id, report_name, report_type, file_path)\n        VALUES (?, ?, ?, ?)\n    \"\"\", (user_id, report_name, report_type, file_path))\n    \n    conn.commit()\n    conn.close()\n\ndef get_user_reports(user_id):\n    \"\"\"Get user's generated reports\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    cursor.execute(\"\"\"\n        SELECT * FROM reports \n        WHERE user_id = ? \n        ORDER BY created_at DESC\n    \"\"\", (user_id,))\n    \n    reports = cursor.fetchall()\n    conn.close()\n    \n    return [dict(report) for report in reports]\n","size_bytes":20583},"shodan_integration.py":{"content":"import requests\nimport streamlit as st\nimport json\nimport os\nfrom datetime import datetime\nimport folium\nfrom streamlit_folium import st_folium\n\nSHODAN_API_KEY = os.getenv(\"SHODAN_API_KEY\", \"\")\nSHODAN_BASE_URL = \"https://api.shodan.io\"\n\ndef search_shodan(query, limit=100):\n    \"\"\"Search Shodan for hosts\"\"\"\n    if not SHODAN_API_KEY:\n        st.error(\"‚ùå Shodan API key not configured. Please set SHODAN_API_KEY environment variable.\")\n        return None\n    \n    try:\n        url = f\"{SHODAN_BASE_URL}/shodan/host/search\"\n        params = {\n            'key': SHODAN_API_KEY,\n            'query': query,\n            'limit': limit\n        }\n        \n        response = requests.get(url, params=params, timeout=30)\n        \n        if response.status_code == 200:\n            return response.json()\n        else:\n            st.error(f\"Shodan API Error: {response.status_code}\")\n            return None\n            \n    except Exception as e:\n        st.error(f\"Error searching Shodan: {str(e)}\")\n        return None\n\ndef get_host_info(ip_address):\n    \"\"\"Get detailed information for a specific IP\"\"\"\n    if not SHODAN_API_KEY:\n        st.error(\"‚ùå Shodan API key not configured.\")\n        return None\n    \n    try:\n        url = f\"{SHODAN_BASE_URL}/shodan/host/{ip_address}\"\n        params = {'key': SHODAN_API_KEY}\n        \n        response = requests.get(url, params=params, timeout=30)\n        \n        if response.status_code == 200:\n            return response.json()\n        else:\n            st.error(f\"Shodan API Error: {response.status_code}\")\n            return None\n            \n    except Exception as e:\n        st.error(f\"Error getting host info: {str(e)}\")\n        return None\n\ndef analyze_exposure_risk(host_data):\n    \"\"\"Analyze exposure risk based on Shodan data\"\"\"\n    risk_factors = []\n    risk_score = 0\n    \n    # Check for dangerous services\n    dangerous_services = ['ftp', 'telnet', 'ssh', 'rdp', 'vnc', 'mongodb', 'elasticsearch', 'redis']\n    \n    for service in host_data.get('data', []):\n        port = service.get('port', 0)\n        product = service.get('product', '').lower()\n        \n        # High-risk ports\n        if port in [21, 23, 1433, 3306, 5432, 6379, 9200, 27017]:\n            risk_factors.append(f\"High-risk port {port} open\")\n            risk_score += 3\n        \n        # Dangerous services\n        for dangerous in dangerous_services:\n            if dangerous in product:\n                risk_factors.append(f\"Potentially dangerous service: {product}\")\n                risk_score += 2\n        \n        # Default credentials indicators\n        if 'default' in service.get('banner', '').lower():\n            risk_factors.append(\"Potential default credentials detected\")\n            risk_score += 3\n    \n    # Location risk (data centers, cloud providers)\n    org = host_data.get('org', '').lower()\n    if any(provider in org for provider in ['amazon', 'google', 'microsoft', 'digitalocean']):\n        risk_factors.append(\"Hosted on major cloud provider\")\n        risk_score += 1\n    \n    # Determine risk level\n    if risk_score >= 8:\n        risk_level = \"üî¥ CRITICAL\"\n    elif risk_score >= 5:\n        risk_level = \"üü† HIGH\"\n    elif risk_score >= 2:\n        risk_level = \"üü° MEDIUM\"\n    else:\n        risk_level = \"üü¢ LOW\"\n    \n    return {\n        'risk_level': risk_level,\n        'risk_score': risk_score,\n        'risk_factors': risk_factors\n    }\n\ndef render_shodan_intelligence():\n    \"\"\"Render Shodan intelligence interface\"\"\"\n    st.title(\"üåç Shodan Intelligence Platform\")\n    st.markdown(\"**Global internet exposure analysis and reconnaissance**\")\n    \n    if not SHODAN_API_KEY:\n        st.error(\"‚ö†Ô∏è **Shodan API Key Required**\")\n        st.info(\"To use Shodan Intelligence features, please set your SHODAN_API_KEY environment variable.\")\n        st.markdown(\"\"\"\n        **How to get a Shodan API key:**\n        1. Visit [shodan.io](https://www.shodan.io/)\n        2. Create a free account\n        3. Go to your account page to find your API key\n        4. Set the SHODAN_API_KEY environment variable\n        \"\"\")\n        return\n    \n    # Tabs for different search types\n    tab1, tab2, tab3 = st.tabs([\"üîç Search Internet\", \"üéØ Host Analysis\", \"üó∫Ô∏è Threat Map\"])\n    \n    with tab1:\n        st.markdown(\"### üîç Internet-wide Search\")\n        \n        col1, col2 = st.columns([3, 1])\n        \n        with col1:\n            search_query = st.text_input(\n                \"Shodan Query\",\n                placeholder=\"port:22 country:US\",\n                help=\"Enter Shodan search query (e.g., 'apache', 'port:80', 'country:US')\"\n            )\n        \n        with col2:\n            limit = st.selectbox(\"Results Limit\", [50, 100, 200], index=1)\n        \n        # Query examples\n        st.markdown(\"**Example Queries:**\")\n        examples = [\n            \"apache\",\n            \"nginx\",\n            \"port:22\",\n            \"port:80 country:US\", \n            \"mongodb\",\n            \"redis\",\n            \"elasticsearch\",\n            \"\\\"default password\\\"\"\n        ]\n        \n        example_cols = st.columns(4)\n        for i, example in enumerate(examples):\n            with example_cols[i % 4]:\n                if st.button(f\"`{example}`\", key=f\"example_{i}\"):\n                    st.session_state.shodan_query = example\n        \n        # Use example query if selected\n        if 'shodan_query' in st.session_state:\n            search_query = st.session_state.shodan_query\n            del st.session_state.shodan_query\n        \n        if st.button(\"üöÄ Search Shodan\", type=\"primary\"):\n            if search_query:\n                with st.spinner(\"üîç Searching global internet data...\"):\n                    results = search_shodan(search_query, limit)\n                    \n                    if results:\n                        display_shodan_results(results)\n            else:\n                st.error(\"Please enter a search query\")\n    \n    with tab2:\n        st.markdown(\"### üéØ Host Intelligence Analysis\")\n        \n        ip_address = st.text_input(\n            \"IP Address\",\n            placeholder=\"8.8.8.8\",\n            help=\"Enter an IP address to get detailed intelligence\"\n        )\n        \n        if st.button(\"üîç Analyze Host\", type=\"primary\"):\n            if ip_address:\n                with st.spinner(\"üìä Gathering host intelligence...\"):\n                    host_data = get_host_info(ip_address)\n                    \n                    if host_data:\n                        display_host_analysis(host_data)\n            else:\n                st.error(\"Please enter an IP address\")\n    \n    with tab3:\n        st.markdown(\"### üó∫Ô∏è Global Threat Visualization\")\n        \n        # Create a simple threat map\n        if st.button(\"üåç Generate Threat Map\"):\n            with st.spinner(\"üó∫Ô∏è Creating global threat map...\"):\n                create_threat_map()\n\ndef display_shodan_results(results):\n    \"\"\"Display Shodan search results\"\"\"\n    st.markdown(\"## üìä Search Results\")\n    \n    # Summary metrics\n    total_results = results.get('total', 0)\n    matches = results.get('matches', [])\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        st.metric(\"Total Found\", f\"{total_results:,}\")\n    \n    with col2:\n        st.metric(\"Displayed\", len(matches))\n    \n    with col3:\n        countries = set(match.get('location', {}).get('country_name', 'Unknown') for match in matches)\n        st.metric(\"Countries\", len(countries))\n    \n    # Country breakdown\n    if matches:\n        country_counts = {}\n        for match in matches:\n            country = match.get('location', {}).get('country_name', 'Unknown')\n            country_counts[country] = country_counts.get(country, 0) + 1\n        \n        st.markdown(\"### üåç Geographic Distribution\")\n        for country, count in sorted(country_counts.items(), key=lambda x: x[1], reverse=True)[:10]:\n            st.write(f\"**{country}:** {count} hosts\")\n    \n    # Individual results\n    st.markdown(\"### üéØ Host Details\")\n    \n    for i, match in enumerate(matches[:20]):  # Limit to first 20 for display\n        ip = match.get('ip_str', 'Unknown')\n        port = match.get('port', 'Unknown')\n        org = match.get('org', 'Unknown')\n        location = match.get('location', {})\n        country = location.get('country_name', 'Unknown')\n        city = location.get('city', 'Unknown')\n        \n        with st.expander(f\"üåê {ip}:{port} - {org} ({country})\"):\n            col1, col2 = st.columns(2)\n            \n            with col1:\n                st.write(f\"**IP Address:** {ip}\")\n                st.write(f\"**Port:** {port}\")\n                st.write(f\"**Organization:** {org}\")\n                st.write(f\"**Location:** {city}, {country}\")\n            \n            with col2:\n                # Risk analysis\n                risk_analysis = analyze_exposure_risk({'data': [match]})\n                st.write(f\"**Risk Level:** {risk_analysis['risk_level']}\")\n                st.write(f\"**Risk Score:** {risk_analysis['risk_score']}/10\")\n                \n                if risk_analysis['risk_factors']:\n                    st.write(\"**Risk Factors:**\")\n                    for factor in risk_analysis['risk_factors'][:3]:\n                        st.write(f\"‚Ä¢ {factor}\")\n            \n            # Banner information\n            banner = match.get('banner', '').strip()\n            if banner:\n                st.markdown(\"**Service Banner:**\")\n                st.code(banner[:500] + \"...\" if len(banner) > 500 else banner)\n\ndef display_host_analysis(host_data):\n    \"\"\"Display detailed host analysis\"\"\"\n    st.markdown(\"## üéØ Host Intelligence Report\")\n    \n    # Basic information\n    ip = host_data.get('ip_str', 'Unknown')\n    org = host_data.get('org', 'Unknown')\n    isp = host_data.get('isp', 'Unknown')\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        st.metric(\"IP Address\", ip)\n    \n    with col2:\n        st.metric(\"Organization\", org)\n    \n    with col3:\n        open_ports = len(host_data.get('data', []))\n        st.metric(\"Open Ports\", open_ports)\n    \n    # Location information\n    location = host_data.get('location', {})\n    if location:\n        st.markdown(\"### üåç Location Information\")\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.write(f\"**Country:** {location.get('country_name', 'Unknown')}\")\n        \n        with col2:\n            st.write(f\"**City:** {location.get('city', 'Unknown')}\")\n        \n        with col3:\n            st.write(f\"**Region:** {location.get('region_code', 'Unknown')}\")\n        \n        with col4:\n            st.write(f\"**Postal Code:** {location.get('postal_code', 'Unknown')}\")\n    \n    # Risk analysis\n    risk_analysis = analyze_exposure_risk(host_data)\n    st.markdown(\"### ‚ö†Ô∏è Exposure Risk Assessment\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.metric(\"Risk Level\", risk_analysis['risk_level'])\n    \n    with col2:\n        st.metric(\"Risk Score\", f\"{risk_analysis['risk_score']}/10\")\n    \n    if risk_analysis['risk_factors']:\n        st.markdown(\"**Risk Factors:**\")\n        for factor in risk_analysis['risk_factors']:\n            st.write(f\"‚Ä¢ {factor}\")\n    \n    # Open ports and services\n    services = host_data.get('data', [])\n    if services:\n        st.markdown(\"### üîå Open Ports & Services\")\n        \n        for service in services:\n            port = service.get('port', 'Unknown')\n            product = service.get('product', 'Unknown')\n            version = service.get('version', '')\n            \n            with st.expander(f\"Port {port} - {product} {version}\"):\n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    st.write(f\"**Port:** {port}\")\n                    st.write(f\"**Service:** {product}\")\n                    if version:\n                        st.write(f\"**Version:** {version}\")\n                    st.write(f\"**Protocol:** {service.get('transport', 'Unknown')}\")\n                \n                with col2:\n                    timestamp = service.get('timestamp', '')\n                    if timestamp:\n                        st.write(f\"**Last Seen:** {timestamp}\")\n                    \n                    if service.get('ssl'):\n                        st.write(\"**SSL/TLS:** ‚úÖ Enabled\")\n                    else:\n                        st.write(\"**SSL/TLS:** ‚ùå Disabled\")\n                \n                banner = service.get('banner', '').strip()\n                if banner:\n                    st.markdown(\"**Service Banner:**\")\n                    st.code(banner[:300] + \"...\" if len(banner) > 300 else banner)\n\ndef create_threat_map():\n    \"\"\"Create a simple threat visualization map\"\"\"\n    st.markdown(\"### üó∫Ô∏è Global Threat Landscape\")\n    \n    # Create a basic world map with threat indicators\n    m = folium.Map(location=[20, 0], zoom_start=2)\n    \n    # Add some example threat markers (in a real implementation, these would come from Shodan data)\n    threat_locations = [\n        {\"lat\": 40.7128, \"lon\": -74.0060, \"city\": \"New York\", \"threats\": 1250},\n        {\"lat\": 51.5074, \"lon\": -0.1278, \"city\": \"London\", \"threats\": 890},\n        {\"lat\": 35.6762, \"lon\": 139.6503, \"city\": \"Tokyo\", \"threats\": 750},\n        {\"lat\": 55.7558, \"lon\": 37.6176, \"city\": \"Moscow\", \"threats\": 620},\n        {\"lat\": 39.9042, \"lon\": 116.4074, \"city\": \"Beijing\", \"threats\": 1100},\n    ]\n    \n    for location in threat_locations:\n        # Color code by threat count\n        if location[\"threats\"] > 1000:\n            color = \"red\"\n        elif location[\"threats\"] > 500:\n            color = \"orange\"\n        else:\n            color = \"yellow\"\n        \n        folium.CircleMarker(\n            location=[location[\"lat\"], location[\"lon\"]],\n            radius=location[\"threats\"] / 100,\n            popup=f\"{location['city']}: {location['threats']} threats\",\n            color=color,\n            fill=True\n        ).add_to(m)\n    \n    # Display the map\n    st_folium(m, width=700, height=500)\n    \n    st.info(\"üí° **Note:** This is a demonstration map. In a real implementation, this would show actual threat data from Shodan searches.\")\n\ndef get_shodan_statistics():\n    \"\"\"Get Shodan statistics for dashboard\"\"\"\n    if not SHODAN_API_KEY:\n        return {\n            'total_devices': 0,\n            'vulnerable_services': 0,\n            'countries_monitored': 0,\n            'api_status': 'No API Key'\n        }\n    \n    try:\n        # Get API info\n        url = f\"{SHODAN_BASE_URL}/api-info\"\n        params = {'key': SHODAN_API_KEY}\n        \n        response = requests.get(url, params=params, timeout=10)\n        \n        if response.status_code == 200:\n            info = response.json()\n            return {\n                'total_devices': info.get('query_credits', 0),\n                'vulnerable_services': 1234,  # Example number\n                'countries_monitored': 195,\n                'api_status': 'Active'\n            }\n        else:\n            return {\n                'total_devices': 0,\n                'vulnerable_services': 0,\n                'countries_monitored': 0,\n                'api_status': 'API Error'\n            }\n            \n    except Exception:\n        return {\n            'total_devices': 0,\n            'vulnerable_services': 0,\n            'countries_monitored': 0,\n            'api_status': 'Connection Error'\n        }\n","size_bytes":15410},"utils.py":{"content":"import streamlit as st\nimport re\nimport ipaddress\nfrom urllib.parse import urlparse\nimport json\nfrom datetime import datetime, timedelta\nimport hashlib\nimport secrets\nimport base64\n\ndef validate_ip_address(ip):\n    \"\"\"Validate IP address format\"\"\"\n    try:\n        ipaddress.ip_address(ip)\n        return True\n    except ValueError:\n        return False\n\ndef validate_url(url):\n    \"\"\"Validate URL format\"\"\"\n    try:\n        result = urlparse(url)\n        return all([result.scheme, result.netloc])\n    except:\n        return False\n\ndef validate_domain(domain):\n    \"\"\"Validate domain name format\"\"\"\n    pattern = re.compile(\n        r'^[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?)*$'\n    )\n    return pattern.match(domain) is not None\n\ndef validate_cve_id(cve_id):\n    \"\"\"Validate CVE ID format\"\"\"\n    pattern = re.compile(r'^CVE-\\d{4}-\\d{4,}$')\n    return pattern.match(cve_id) is not None\n\ndef sanitize_filename(filename):\n    \"\"\"Sanitize filename for safe file operations\"\"\"\n    # Remove dangerous characters\n    filename = re.sub(r'[<>:\"/\\\\|?*]', '_', filename)\n    # Remove leading/trailing spaces and dots\n    filename = filename.strip(' .')\n    # Limit length\n    filename = filename[:255]\n    return filename\n\ndef format_timestamp(timestamp):\n    \"\"\"Format timestamp for display\"\"\"\n    try:\n        if isinstance(timestamp, str):\n            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))\n        else:\n            dt = timestamp\n        \n        return dt.strftime('%Y-%m-%d %H:%M:%S')\n    except:\n        return \"Unknown\"\n\ndef format_file_size(size_bytes):\n    \"\"\"Format file size in human readable format\"\"\"\n    if size_bytes == 0:\n        return \"0 B\"\n    \n    size_names = [\"B\", \"KB\", \"MB\", \"GB\"]\n    i = 0\n    while size_bytes >= 1024 and i < len(size_names) - 1:\n        size_bytes /= 1024.0\n        i += 1\n    \n    return f\"{size_bytes:.1f} {size_names[i]}\"\n\ndef generate_session_id():\n    \"\"\"Generate secure session ID\"\"\"\n    return secrets.token_urlsafe(32)\n\ndef hash_data(data):\n    \"\"\"Hash data using SHA-256\"\"\"\n    return hashlib.sha256(str(data).encode()).hexdigest()\n\ndef encode_data(data):\n    \"\"\"Base64 encode data\"\"\"\n    return base64.b64encode(json.dumps(data).encode()).decode()\n\ndef decode_data(encoded_data):\n    \"\"\"Base64 decode data\"\"\"\n    try:\n        return json.loads(base64.b64decode(encoded_data.encode()).decode())\n    except:\n        return None\n\ndef parse_port_range(port_range):\n    \"\"\"Parse port range string into list of ports\"\"\"\n    ports = []\n    \n    try:\n        if '-' in port_range:\n            start, end = port_range.split('-')\n            start, end = int(start), int(end)\n            if 1 <= start <= 65535 and 1 <= end <= 65535 and start <= end:\n                ports = list(range(start, end + 1))\n        elif ',' in port_range:\n            port_list = port_range.split(',')\n            for port in port_list:\n                port = int(port.strip())\n                if 1 <= port <= 65535:\n                    ports.append(port)\n        else:\n            port = int(port_range)\n            if 1 <= port <= 65535:\n                ports = [port]\n    except ValueError:\n        pass\n    \n    return ports\n\ndef format_scan_duration(start_time, end_time=None):\n    \"\"\"Format scan duration\"\"\"\n    try:\n        if isinstance(start_time, str):\n            start = datetime.fromisoformat(start_time.replace('Z', '+00:00'))\n        else:\n            start = start_time\n        \n        if end_time:\n            if isinstance(end_time, str):\n                end = datetime.fromisoformat(end_time.replace('Z', '+00:00'))\n            else:\n                end = end_time\n        else:\n            end = datetime.now()\n        \n        duration = end - start\n        \n        if duration.total_seconds() < 60:\n            return f\"{duration.total_seconds():.1f} seconds\"\n        elif duration.total_seconds() < 3600:\n            return f\"{duration.total_seconds() / 60:.1f} minutes\"\n        else:\n            return f\"{duration.total_seconds() / 3600:.1f} hours\"\n    except:\n        return \"Unknown\"\n\ndef get_risk_color(risk_level):\n    \"\"\"Get color for risk level\"\"\"\n    colors = {\n        'critical': '#8B0000',\n        'high': '#FF4B4B',\n        'medium': '#FFA500',\n        'low': '#32CD32',\n        'info': '#4169E1',\n        'none': '#808080'\n    }\n    return colors.get(risk_level.lower(), '#808080')\n\ndef get_risk_emoji(risk_level):\n    \"\"\"Get emoji for risk level\"\"\"\n    emojis = {\n        'critical': 'üî¥',\n        'high': 'üî¥', \n        'medium': 'üü°',\n        'low': 'üü¢',\n        'info': 'üîµ',\n        'none': '‚ö™'\n    }\n    return emojis.get(risk_level.lower(), '‚ö™')\n\ndef truncate_text(text, max_length=100):\n    \"\"\"Truncate text to specified length\"\"\"\n    if len(text) <= max_length:\n        return text\n    return text[:max_length] + \"...\"\n\ndef display_success_message(message, duration=5):\n    \"\"\"Display success message with auto-dismiss\"\"\"\n    success_container = st.success(message)\n    if duration > 0:\n        # In a real implementation, this would use JavaScript for auto-dismiss\n        pass\n\ndef display_error_message(message, details=None):\n    \"\"\"Display error message with optional details\"\"\"\n    st.error(message)\n    if details:\n        with st.expander(\"Error Details\"):\n            st.code(details)\n\ndef display_info_message(message, icon=\"‚ÑπÔ∏è\"):\n    \"\"\"Display info message with custom icon\"\"\"\n    st.info(f\"{icon} {message}\")\n\ndef create_download_link(data, filename, link_text=\"Download\"):\n    \"\"\"Create download link for data\"\"\"\n    if isinstance(data, dict):\n        data = json.dumps(data, indent=2)\n    \n    b64_data = base64.b64encode(data.encode()).decode()\n    \n    return f'<a href=\"data:text/plain;base64,{b64_data}\" download=\"{filename}\" style=\"text-decoration: none; color: #FF4B4B; font-weight: bold;\">{link_text}</a>'\n\ndef parse_user_agent(user_agent):\n    \"\"\"Parse user agent string\"\"\"\n    # Simple user agent parsing\n    if 'Chrome' in user_agent:\n        return {'browser': 'Chrome', 'type': 'Browser'}\n    elif 'Firefox' in user_agent:\n        return {'browser': 'Firefox', 'type': 'Browser'}\n    elif 'curl' in user_agent.lower():\n        return {'browser': 'curl', 'type': 'Tool'}\n    elif 'nmap' in user_agent.lower():\n        return {'browser': 'Nmap', 'type': 'Scanner'}\n    else:\n        return {'browser': 'Unknown', 'type': 'Unknown'}\n\ndef get_country_flag(country_code):\n    \"\"\"Get flag emoji for country code\"\"\"\n    # Simplified country code to flag mapping\n    flags = {\n        'US': 'üá∫üá∏', 'CN': 'üá®üá≥', 'RU': 'üá∑üá∫', 'DE': 'üá©üá™', 'GB': 'üá¨üáß',\n        'FR': 'üá´üá∑', 'JP': 'üáØüáµ', 'KR': 'üá∞üá∑', 'IN': 'üáÆüá≥', 'BR': 'üáßüá∑',\n        'CA': 'üá®üá¶', 'AU': 'üá¶üá∫', 'IT': 'üáÆüáπ', 'ES': 'üá™üá∏', 'NL': 'üá≥üá±'\n    }\n    return flags.get(country_code.upper(), 'üè≥Ô∏è')\n\ndef format_cvss_score(score):\n    \"\"\"Format CVSS score with color and description\"\"\"\n    if score >= 9.0:\n        return f\"üî¥ {score}/10 (Critical)\"\n    elif score >= 7.0:\n        return f\"üü† {score}/10 (High)\"\n    elif score >= 4.0:\n        return f\"üü° {score}/10 (Medium)\"\n    elif score >= 0.1:\n        return f\"üü¢ {score}/10 (Low)\"\n    else:\n        return f\"‚ö™ {score}/10 (None)\"\n\ndef check_rate_limit(user_id, action, limit=10, window=3600):\n    \"\"\"Simple rate limiting check\"\"\"\n    # In a real implementation, this would use Redis or database\n    # For now, just return True (no rate limiting)\n    return True\n\ndef log_security_event(user_id, event_type, details):\n    \"\"\"Log security events\"\"\"\n    # In a real implementation, this would log to security monitoring system\n    timestamp = datetime.now().isoformat()\n    event = {\n        'timestamp': timestamp,\n        'user_id': user_id,\n        'event_type': event_type,\n        'details': details\n    }\n    \n    # For demo, we'll just print to console\n    print(f\"Security Event: {json.dumps(event)}\")\n\ndef mask_sensitive_data(data, fields=['password', 'api_key', 'token']):\n    \"\"\"Mask sensitive fields in data\"\"\"\n    if isinstance(data, dict):\n        masked_data = data.copy()\n        for field in fields:\n            if field in masked_data:\n                masked_data[field] = '*' * 8\n        return masked_data\n    return data\n\ndef generate_report_id():\n    \"\"\"Generate unique report ID\"\"\"\n    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n    random_suffix = secrets.token_hex(4)\n    return f\"RPT_{timestamp}_{random_suffix}\"\n\ndef validate_scan_target(target, scan_type):\n    \"\"\"Validate scan target based on scan type\"\"\"\n    if scan_type in ['port_scan', 'network_scan']:\n        return validate_ip_address(target) or validate_domain(target)\n    elif scan_type in ['web_scan', 'ssl_scan']:\n        return validate_url(target)\n    elif scan_type == 'cve_search':\n        return validate_cve_id(target) or len(target.strip()) > 2\n    else:\n        return len(target.strip()) > 0\n\ndef get_scan_type_icon(scan_type):\n    \"\"\"Get icon for scan type\"\"\"\n    icons = {\n        'port_scan': 'üîç',\n        'web_scan': 'üåê',\n        'ssl_scan': 'üîí',\n        'cve_search': 'üõ°Ô∏è',\n        'shodan_search': 'üåç',\n        'exploit_search': 'üí•'\n    }\n    return icons.get(scan_type, 'üìä')\n\ndef calculate_security_score(scan_results):\n    \"\"\"Calculate overall security score from scan results\"\"\"\n    total_score = 100\n    \n    for scan_type, results in scan_results.items():\n        if scan_type == 'port_scan':\n            open_ports = len(results.get('open_ports', []))\n            if open_ports > 20:\n                total_score -= 30\n            elif open_ports > 10:\n                total_score -= 20\n            elif open_ports > 5:\n                total_score -= 10\n                \n        elif scan_type == 'web_scan':\n            risk_summary = results.get('risk_summary', {})\n            total_score -= risk_summary.get('high', 0) * 15\n            total_score -= risk_summary.get('medium', 0) * 8\n            total_score -= risk_summary.get('low', 0) * 3\n    \n    return max(0, min(100, total_score))\n\ndef export_scan_results(scan_results, format='json'):\n    \"\"\"Export scan results in specified format\"\"\"\n    if format == 'json':\n        return json.dumps(scan_results, indent=2)\n    elif format == 'csv':\n        # Simple CSV export (would need proper CSV library for complex data)\n        return \"CSV export not implemented in demo\"\n    else:\n        return str(scan_results)\n\ndef get_time_ago(timestamp):\n    \"\"\"Get human-readable time ago string\"\"\"\n    try:\n        if isinstance(timestamp, str):\n            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))\n        else:\n            dt = timestamp\n        \n        now = datetime.now()\n        diff = now - dt.replace(tzinfo=None)\n        \n        if diff.days > 0:\n            return f\"{diff.days} day{'s' if diff.days != 1 else ''} ago\"\n        elif diff.seconds > 3600:\n            hours = diff.seconds // 3600\n            return f\"{hours} hour{'s' if hours != 1 else ''} ago\"\n        elif diff.seconds > 60:\n            minutes = diff.seconds // 60\n            return f\"{minutes} minute{'s' if minutes != 1 else ''} ago\"\n        else:\n            return \"Just now\"\n    except:\n        return \"Unknown time\"\n","size_bytes":11285},"web_scanner.py":{"content":"import requests\nimport ssl\nimport socket\nimport streamlit as st\nimport json\nfrom datetime import datetime\nfrom urllib.parse import urljoin, urlparse\nimport urllib3\n\n# Suppress SSL warnings for testing\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\n# Common vulnerability paths to check\nVULN_PATHS = [\n    '/admin',\n    '/admin.php',\n    '/administrator',\n    '/phpmyadmin',\n    '/wp-admin',\n    '/wp-login.php',\n    '/login',\n    '/robots.txt',\n    '/.htaccess',\n    '/.env',\n    '/config.php',\n    '/backup',\n    '/backup.sql',\n    '/database.sql',\n    '/.git',\n    '/.svn',\n    '/test',\n    '/debug',\n    '/info.php',\n    '/phpinfo.php'\n]\n\n# Security headers to check\nSECURITY_HEADERS = [\n    'X-Content-Type-Options',\n    'X-Frame-Options',\n    'X-XSS-Protection',\n    'Strict-Transport-Security',\n    'Content-Security-Policy',\n    'Referrer-Policy',\n    'Permissions-Policy',\n    'X-Permitted-Cross-Domain-Policies'\n]\n\ndef check_ssl_certificate(hostname, port=443):\n    \"\"\"Check SSL certificate details\"\"\"\n    try:\n        context = ssl.create_default_context()\n        with socket.create_connection((hostname, port), timeout=10) as sock:\n            with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                cert = ssock.getpeercert()\n                \n                return {\n                    'valid': True,\n                    'subject': dict(x[0] for x in cert['subject']),\n                    'issuer': dict(x[0] for x in cert['issuer']),\n                    'version': cert['version'],\n                    'serial_number': cert['serialNumber'],\n                    'not_before': cert['notBefore'],\n                    'not_after': cert['notAfter'],\n                    'signature_algorithm': cert.get('signatureAlgorithm', 'Unknown')\n                }\n    except Exception as e:\n        return {\n            'valid': False,\n            'error': str(e)\n        }\n\ndef check_security_headers(url):\n    \"\"\"Check security headers\"\"\"\n    try:\n        response = requests.get(url, timeout=10, verify=False)\n        headers_found = {}\n        missing_headers = []\n        \n        for header in SECURITY_HEADERS:\n            if header in response.headers:\n                headers_found[header] = response.headers[header]\n            else:\n                missing_headers.append(header)\n        \n        return {\n            'status_code': response.status_code,\n            'headers_found': headers_found,\n            'missing_headers': missing_headers,\n            'all_headers': dict(response.headers)\n        }\n    except Exception as e:\n        return {\n            'error': str(e)\n        }\n\ndef check_common_vulnerabilities(base_url):\n    \"\"\"Check for common vulnerability paths\"\"\"\n    findings = []\n    \n    for path in VULN_PATHS:\n        try:\n            url = urljoin(base_url, path)\n            response = requests.get(url, timeout=5, verify=False, allow_redirects=False)\n            \n            if response.status_code == 200:\n                findings.append({\n                    'path': path,\n                    'url': url,\n                    'status_code': response.status_code,\n                    'content_length': len(response.content),\n                    'content_type': response.headers.get('Content-Type', 'Unknown'),\n                    'risk': classify_path_risk(path, response)\n                })\n            elif response.status_code in [301, 302, 307, 308]:\n                findings.append({\n                    'path': path,\n                    'url': url,\n                    'status_code': response.status_code,\n                    'redirect_to': response.headers.get('Location', 'Unknown'),\n                    'risk': 'Low'\n                })\n        except:\n            continue\n    \n    return findings\n\ndef classify_path_risk(path, response):\n    \"\"\"Classify risk level of discovered paths\"\"\"\n    high_risk_indicators = ['.env', 'config.php', 'backup', '.git', '.svn', 'database', 'phpinfo']\n    medium_risk_indicators = ['admin', 'login', 'wp-admin', 'phpmyadmin']\n    \n    path_lower = path.lower()\n    content = response.text.lower() if hasattr(response, 'text') else ''\n    \n    for indicator in high_risk_indicators:\n        if indicator in path_lower or indicator in content:\n            return 'High'\n    \n    for indicator in medium_risk_indicators:\n        if indicator in path_lower:\n            return 'Medium'\n    \n    return 'Low'\n\ndef check_http_methods(url):\n    \"\"\"Check supported HTTP methods\"\"\"\n    methods = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'HEAD', 'PATCH', 'TRACE']\n    supported_methods = []\n    \n    for method in methods:\n        try:\n            response = requests.request(method, url, timeout=5, verify=False)\n            if response.status_code not in [405, 501]:\n                supported_methods.append({\n                    'method': method,\n                    'status_code': response.status_code,\n                    'risk': 'High' if method in ['PUT', 'DELETE', 'TRACE'] else 'Low'\n                })\n        except:\n            continue\n    \n    return supported_methods\n\ndef perform_web_scan(url, progress_callback=None):\n    \"\"\"Perform comprehensive web vulnerability scan\"\"\"\n    results = {\n        'url': url,\n        'scan_time': datetime.now().isoformat(),\n        'ssl_info': {},\n        'security_headers': {},\n        'vulnerability_paths': [],\n        'http_methods': [],\n        'server_info': {},\n        'risk_summary': {\n            'high': 0,\n            'medium': 0,\n            'low': 0\n        }\n    }\n    \n    total_checks = 5\n    completed = 0\n    \n    def update_progress():\n        nonlocal completed\n        completed += 1\n        if progress_callback:\n            progress_callback(completed / total_checks)\n    \n    # Parse URL\n    parsed_url = urlparse(url)\n    hostname = parsed_url.hostname\n    \n    # 1. SSL Certificate Check\n    if parsed_url.scheme == 'https':\n        results['ssl_info'] = check_ssl_certificate(hostname)\n    update_progress()\n    \n    # 2. Security Headers Check\n    results['security_headers'] = check_security_headers(url)\n    update_progress()\n    \n    # 3. Common Vulnerability Paths\n    results['vulnerability_paths'] = check_common_vulnerabilities(url)\n    update_progress()\n    \n    # 4. HTTP Methods Check\n    results['http_methods'] = check_http_methods(url)\n    update_progress()\n    \n    # 5. Server Information\n    try:\n        response = requests.get(url, timeout=10, verify=False)\n        results['server_info'] = {\n            'server': response.headers.get('Server', 'Unknown'),\n            'powered_by': response.headers.get('X-Powered-By', 'Unknown'),\n            'status_code': response.status_code,\n            'content_type': response.headers.get('Content-Type', 'Unknown')\n        }\n    except Exception as e:\n        results['server_info'] = {'error': str(e)}\n    update_progress()\n    \n    # Calculate risk summary\n    calculate_risk_summary(results)\n    \n    return results\n\ndef calculate_risk_summary(results):\n    \"\"\"Calculate overall risk summary\"\"\"\n    risk_counts = {'high': 0, 'medium': 0, 'low': 0}\n    \n    # SSL risks\n    if 'ssl_info' in results and not results['ssl_info'].get('valid', True):\n        risk_counts['high'] += 1\n    \n    # Security headers risks\n    if 'security_headers' in results:\n        missing_count = len(results['security_headers'].get('missing_headers', []))\n        if missing_count > 5:\n            risk_counts['high'] += 1\n        elif missing_count > 2:\n            risk_counts['medium'] += 1\n    \n    # Vulnerability paths\n    for vuln in results.get('vulnerability_paths', []):\n        risk_level = vuln.get('risk', 'Low').lower()\n        risk_counts[risk_level] += 1\n    \n    # HTTP methods\n    for method in results.get('http_methods', []):\n        risk_level = method.get('risk', 'Low').lower()\n        risk_counts[risk_level] += 1\n    \n    results['risk_summary'] = risk_counts\n\ndef render_web_scanner():\n    \"\"\"Render web vulnerability scanner interface\"\"\"\n    st.title(\"üåê Web Vulnerability Scanner\")\n    st.markdown(\"**Comprehensive HTTP security analysis with SSL/TLS verification and vulnerability detection**\")\n    \n    # Check authentication and limits\n    from auth import check_scan_limit\n    if not check_scan_limit():\n        return\n    \n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        # URL input\n        url = st.text_input(\n            \"üéØ Target URL\",\n            placeholder=\"https://example.com\",\n            help=\"Enter a complete URL including http:// or https://\"\n        )\n        \n        # Scan options\n        st.markdown(\"### üîß Scan Options\")\n        scan_ssl = st.checkbox(\"üîí SSL/TLS Analysis\", value=True)\n        scan_headers = st.checkbox(\"üõ°Ô∏è Security Headers\", value=True)\n        scan_paths = st.checkbox(\"üîç Vulnerability Paths\", value=True)\n        scan_methods = st.checkbox(\"üì° HTTP Methods\", value=True)\n    \n    with col2:\n        st.markdown(\"### üöÄ Quick Targets\")\n        if st.button(\"üåê Test HTTPS Site\"):\n            st.session_state.web_target = \"https://www.google.com\"\n        if st.button(\"üîì Test HTTP Site\"):\n            st.session_state.web_target = \"http://neverssl.com\"\n        if st.button(\"üè† Test Localhost\"):\n            st.session_state.web_target = \"http://localhost:8080\"\n        \n        # Apply quick target if selected\n        if 'web_target' in st.session_state:\n            url = st.session_state.web_target\n            del st.session_state.web_target\n    \n    # Scan execution\n    if st.button(\"üöÄ Start Web Scan\", type=\"primary\", use_container_width=True):\n        if not url:\n            st.error(\"‚ùå Please enter a target URL\")\n            return\n        \n        if not url.startswith(('http://', 'https://')):\n            st.error(\"‚ùå URL must start with http:// or https://\")\n            return\n        \n        # Progress tracking\n        progress_bar = st.progress(0)\n        status_text = st.empty()\n        results_container = st.empty()\n        \n        def update_progress(progress):\n            progress_bar.progress(progress)\n            status_text.text(f\"üîç Scanning... {progress*100:.1f}% complete\")\n        \n        # Perform scan\n        with st.spinner(\"üöÄ Initializing web vulnerability scan...\"):\n            try:\n                results = perform_web_scan(url, update_progress)\n                \n                # Save scan results\n                user_info = st.session_state.get('user_info', {})\n                if user_info:\n                    from database import save_scan_result\n                    save_scan_result(\n                        user_info['id'],\n                        'web_scan',\n                        url,\n                        json.dumps(results)\n                    )\n                \n                # Display results\n                status_text.text(\"‚úÖ Scan completed!\")\n                display_web_scan_results(results, results_container)\n                \n            except Exception as e:\n                st.error(f\"‚ùå Scan failed: {str(e)}\")\n\ndef display_web_scan_results(results, container):\n    \"\"\"Display web vulnerability scan results\"\"\"\n    with container.container():\n        st.markdown(\"## üìä Web Vulnerability Scan Results\")\n        \n        # Risk summary\n        risk_summary = results.get('risk_summary', {})\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\"üéØ Target\", results['url'])\n        \n        with col2:\n            st.metric(\"üî¥ High Risk\", risk_summary.get('high', 0))\n        \n        with col3:\n            st.metric(\"üü° Medium Risk\", risk_summary.get('medium', 0))\n        \n        with col4:\n            st.metric(\"üü¢ Low Risk\", risk_summary.get('low', 0))\n        \n        # SSL Information\n        if 'ssl_info' in results and results['ssl_info']:\n            st.markdown(\"### üîí SSL/TLS Certificate Analysis\")\n            ssl_info = results['ssl_info']\n            \n            if ssl_info.get('valid'):\n                st.success(\"‚úÖ Valid SSL Certificate\")\n                \n                col1, col2 = st.columns(2)\n                with col1:\n                    st.write(\"**Subject:**\", ssl_info['subject'].get('commonName', 'N/A'))\n                    st.write(\"**Issuer:**\", ssl_info['issuer'].get('organizationName', 'N/A'))\n                    st.write(\"**Valid From:**\", ssl_info['not_before'])\n                \n                with col2:\n                    st.write(\"**Valid Until:**\", ssl_info['not_after'])\n                    st.write(\"**Serial Number:**\", ssl_info['serial_number'])\n                    st.write(\"**Signature Algorithm:**\", ssl_info['signature_algorithm'])\n            else:\n                st.error(f\"‚ùå SSL Certificate Error: {ssl_info.get('error', 'Unknown error')}\")\n        \n        # Security Headers\n        if 'security_headers' in results:\n            st.markdown(\"### üõ°Ô∏è Security Headers Analysis\")\n            headers_info = results['security_headers']\n            \n            if 'headers_found' in headers_info:\n                found_headers = headers_info['headers_found']\n                missing_headers = headers_info.get('missing_headers', [])\n                \n                if found_headers:\n                    st.success(f\"‚úÖ Found {len(found_headers)} security headers\")\n                    for header, value in found_headers.items():\n                        st.code(f\"{header}: {value}\")\n                \n                if missing_headers:\n                    st.warning(f\"‚ö†Ô∏è Missing {len(missing_headers)} security headers\")\n                    for header in missing_headers:\n                        st.write(f\"‚ùå {header}\")\n        \n        # Vulnerability Paths\n        if results.get('vulnerability_paths'):\n            st.markdown(\"### üîç Discovered Paths\")\n            \n            for vuln in results['vulnerability_paths']:\n                risk_color = {\"High\": \"üî¥\", \"Medium\": \"üü°\", \"Low\": \"üü¢\"}\n                risk_emoji = risk_color.get(vuln['risk'], \"üü¢\")\n                \n                with st.expander(f\"{risk_emoji} {vuln['path']} - {vuln['risk']} Risk\"):\n                    st.write(f\"**URL:** {vuln['url']}\")\n                    st.write(f\"**Status Code:** {vuln['status_code']}\")\n                    if 'content_length' in vuln:\n                        st.write(f\"**Content Length:** {vuln['content_length']} bytes\")\n                    if 'redirect_to' in vuln:\n                        st.write(f\"**Redirects To:** {vuln['redirect_to']}\")\n        \n        # HTTP Methods\n        if results.get('http_methods'):\n            st.markdown(\"### üì° Supported HTTP Methods\")\n            \n            for method_info in results['http_methods']:\n                risk_color = {\"High\": \"üî¥\", \"Medium\": \"üü°\", \"Low\": \"üü¢\"}\n                risk_emoji = risk_color.get(method_info['risk'], \"üü¢\")\n                \n                col1, col2, col3 = st.columns(3)\n                with col1:\n                    st.write(f\"{risk_emoji} **{method_info['method']}**\")\n                with col2:\n                    st.write(f\"Status: {method_info['status_code']}\")\n                with col3:\n                    st.write(f\"Risk: {method_info['risk']}\")\n        \n        # Server Information\n        if results.get('server_info'):\n            st.markdown(\"### üñ•Ô∏è Server Information\")\n            server_info = results['server_info']\n            \n            col1, col2 = st.columns(2)\n            with col1:\n                st.write(f\"**Server:** {server_info.get('server', 'Unknown')}\")\n                st.write(f\"**Powered By:** {server_info.get('powered_by', 'Unknown')}\")\n            \n            with col2:\n                st.write(f\"**Status Code:** {server_info.get('status_code', 'Unknown')}\")\n                st.write(f\"**Content Type:** {server_info.get('content_type', 'Unknown')}\")\n        \n        # AI Analysis button\n        if st.button(\"ü§ñ Get AI Security Analysis\", key=\"web_ai_analysis\"):\n            with st.spinner(\"üß† Analyzing web scan results...\"):\n                from ai_chat import analyze_scan_results\n                analysis = analyze_scan_results(\"web vulnerability scan\", results)\n                st.markdown(\"### ü§ñ AI Security Analysis\")\n                st.markdown(analysis)\n","size_bytes":16334},"pages/1_ü§ñ_AI_Security_Chat.py":{"content":"import streamlit as st\nfrom ai_chat import render_chat_interface\nfrom auth import check_authentication\n\n# Page configuration\nst.set_page_config(\n    page_title=\"AI Security Chat - CyberSec Platform\",\n    page_icon=\"ü§ñ\",\n    layout=\"wide\"\n)\n\n# Check authentication\nif not check_authentication():\n    st.stop()\n\n# Render the AI chat interface\nrender_chat_interface()\n","size_bytes":367},"pages/2_üîç_Network_Scanner.py":{"content":"import streamlit as st\nfrom port_scanner import render_port_scanner\nfrom auth import check_authentication\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Network Scanner - CyberSec Platform\", \n    page_icon=\"üîç\",\n    layout=\"wide\"\n)\n\n# Check authentication\nif not check_authentication():\n    st.stop()\n\n# Render the port scanner interface\nrender_port_scanner()\n","size_bytes":373},"pages/3_üåê_Web_Vulnerability_Scanner.py":{"content":"import streamlit as st\nfrom web_scanner import render_web_scanner\nfrom auth import check_authentication\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Web Scanner - CyberSec Platform\",\n    page_icon=\"üåê\", \n    layout=\"wide\"\n)\n\n# Check authentication\nif not check_authentication():\n    st.stop()\n\n# Render the web vulnerability scanner interface\nrender_web_scanner()\n","size_bytes":379},"pages/4_üõ°Ô∏è_CVE_Database.py":{"content":"import streamlit as st\nfrom cve_database import render_cve_database\nfrom auth import check_authentication\n\n# Page configuration\nst.set_page_config(\n    page_title=\"CVE Database - CyberSec Platform\",\n    page_icon=\"üõ°Ô∏è\",\n    layout=\"wide\"\n)\n\n# Check authentication\nif not check_authentication():\n    st.stop()\n\n# Render the CVE database interface\nrender_cve_database()\n","size_bytes":372},"pages/5_üåç_Shodan_Intelligence.py":{"content":"import streamlit as st\nfrom shodan_integration import render_shodan_intelligence\nfrom auth import check_authentication\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Shodan Intelligence - CyberSec Platform\",\n    page_icon=\"üåç\",\n    layout=\"wide\"\n)\n\n# Check authentication\nif not check_authentication():\n    st.stop()\n\n# Render the Shodan intelligence interface\nrender_shodan_intelligence()\n","size_bytes":403},"pages/6_üí•_Exploit_Database.py":{"content":"import streamlit as st\nfrom exploit_database import render_exploit_database\nfrom auth import check_authentication\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Exploit Database - CyberSec Platform\",\n    page_icon=\"üí•\",\n    layout=\"wide\"\n)\n\n# Check authentication\nif not check_authentication():\n    st.stop()\n\n# Render the exploit database interface\nrender_exploit_database()\n","size_bytes":389},"pages/7_üìä_Reports.py":{"content":"import streamlit as st\nimport os\nfrom report_generator import generate_scan_report, save_report_record, get_user_reports\nfrom auth import check_authentication\nfrom utils import format_timestamp, format_file_size\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Reports - CyberSec Platform\",\n    page_icon=\"üìä\",\n    layout=\"wide\"\n)\n\n# Check authentication\nif not check_authentication():\n    st.stop()\n\ndef render_reports_page():\n    \"\"\"Render reports management page\"\"\"\n    st.title(\"üìä Security Assessment Reports\")\n    st.markdown(\"**Generate comprehensive PDF reports from your security scans**\")\n    \n    user_info = st.session_state.get('user_info', {})\n    if not user_info:\n        st.error(\"User information not available\")\n        return\n    \n    # Check user tier\n    user_role = user_info.get('role', 'free')\n    \n    if user_role == 'free':\n        st.warning(\"‚ö†Ô∏è **Report Generation is a Pro Feature**\")\n        st.info(\"Upgrade to Professional or Enterprise plan to generate detailed PDF reports\")\n        st.markdown(\"**Pro Features Include:**\")\n        st.markdown(\"‚Ä¢ Executive summary reports\")\n        st.markdown(\"‚Ä¢ Technical vulnerability details\") \n        st.markdown(\"‚Ä¢ Compliance framework mapping\")\n        st.markdown(\"‚Ä¢ Remediation recommendations\")\n        \n        if st.button(\"üöÄ Upgrade to Pro\"):\n            st.switch_page(\"pages/8_üí≥_Billing.py\")\n        return\n    \n    # Report generation section\n    tab1, tab2 = st.tabs([\"üîÑ Generate Report\", \"üìÑ Report History\"])\n    \n    with tab1:\n        st.markdown(\"### üîÑ Generate New Report\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            report_name = st.text_input(\n                \"Report Name\",\n                value=\"Security Assessment Report\",\n                help=\"Enter a descriptive name for your report\"\n            )\n            \n            report_type = st.selectbox(\n                \"Report Type\",\n                [\n                    \"Executive Summary\",\n                    \"Technical Assessment\", \n                    \"Compliance Report\",\n                    \"Vulnerability Analysis\",\n                    \"Full Security Audit\"\n                ],\n                help=\"Select the type of report to generate\"\n            )\n        \n        with col2:\n            include_charts = st.checkbox(\"üìä Include Charts & Graphs\", value=True)\n            include_remediation = st.checkbox(\"üõ†Ô∏è Include Remediation Steps\", value=True)\n            include_compliance = st.checkbox(\"‚úÖ Include Compliance Mapping\", value=True)\n            include_executive_summary = st.checkbox(\"üëî Executive Summary\", value=True)\n        \n        # Report scope\n        st.markdown(\"### üéØ Report Scope\")\n        \n        scope_option = st.radio(\n            \"Include Data From:\",\n            [\n                \"All My Scans\",\n                \"Last 30 Days\", \n                \"Last 7 Days\",\n                \"Custom Date Range\"\n            ],\n            horizontal=True\n        )\n        \n        if scope_option == \"Custom Date Range\":\n            col1, col2 = st.columns(2)\n            with col1:\n                start_date = st.date_input(\"Start Date\")\n            with col2:\n                end_date = st.date_input(\"End Date\")\n        \n        # Generate report button\n        if st.button(\"üöÄ Generate Report\", type=\"primary\", use_container_width=True):\n            if not report_name.strip():\n                st.error(\"Please enter a report name\")\n                return\n            \n            with st.spinner(\"üìä Generating comprehensive security report...\"):\n                try:\n                    # Generate the report\n                    report_file = generate_scan_report(user_info['id'], None, report_name)\n                    \n                    # Save report record\n                    save_report_record(user_info['id'], report_name, report_file, report_type.lower())\n                    \n                    st.success(\"‚úÖ Report generated successfully!\")\n                    \n                    # Provide download link\n                    if os.path.exists(report_file):\n                        with open(report_file, \"rb\") as file:\n                            st.download_button(\n                                label=\"üì• Download Report (PDF)\",\n                                data=file.read(),\n                                file_name=os.path.basename(report_file),\n                                mime=\"application/pdf\",\n                                type=\"primary\"\n                            )\n                    \n                    # Show report preview\n                    st.markdown(\"### üìã Report Generated\")\n                    st.info(f\"**Report Name:** {report_name}\")\n                    st.info(f\"**File Location:** {report_file}\")\n                    st.info(f\"**Report Type:** {report_type}\")\n                    \n                except Exception as e:\n                    st.error(f\"‚ùå Report generation failed: {str(e)}\")\n    \n    with tab2:\n        st.markdown(\"### üìÑ Report History\")\n        \n        # Get user reports\n        reports = get_user_reports(user_info['id'])\n        \n        if not reports:\n            st.info(\"üìù No reports generated yet\")\n            st.markdown(\"Generate your first security report using the **Generate Report** tab above.\")\n            return\n        \n        # Reports table\n        st.markdown(f\"**Total Reports: {len(reports)}**\")\n        \n        for i, report in enumerate(reports):\n            with st.expander(f\"üìä {report['report_name']} - {format_timestamp(report['created_at'])}\"):\n                col1, col2, col3 = st.columns(3)\n                \n                with col1:\n                    st.write(f\"**Name:** {report['report_name']}\")\n                    st.write(f\"**Type:** {report['report_type'].title()}\")\n                \n                with col2:\n                    st.write(f\"**Created:** {format_timestamp(report['created_at'])}\")\n                    \n                    # Check if file exists and get size\n                    if os.path.exists(report['file_path']):\n                        file_size = os.path.getsize(report['file_path'])\n                        st.write(f\"**Size:** {format_file_size(file_size)}\")\n                    else:\n                        st.write(f\"**Size:** File not found\")\n                \n                with col3:\n                    # Download button\n                    if os.path.exists(report['file_path']):\n                        try:\n                            with open(report['file_path'], \"rb\") as file:\n                                st.download_button(\n                                    label=\"üì• Download\",\n                                    data=file.read(),\n                                    file_name=f\"{report['report_name']}.pdf\",\n                                    mime=\"application/pdf\",\n                                    key=f\"download_{report['id']}\"\n                                )\n                        except Exception as e:\n                            st.error(f\"Download error: {str(e)}\")\n                    else:\n                        st.error(\"File not found\")\n                \n                # Report actions\n                st.markdown(\"**Actions:**\")\n                col1, col2, col3 = st.columns(3)\n                \n                with col1:\n                    if st.button(\"üîÑ Regenerate\", key=f\"regen_{report['id']}\"):\n                        st.info(\"Regeneration feature coming soon\")\n                \n                with col2:\n                    if st.button(\"üìß Email\", key=f\"email_{report['id']}\"):\n                        st.info(\"Email feature coming soon\")\n                \n                with col3:\n                    if st.button(\"üóëÔ∏è Delete\", key=f\"delete_{report['id']}\"):\n                        st.warning(\"Delete confirmation coming soon\")\n\n# Render the page\nrender_reports_page()\n","size_bytes":7985},"pages/8_üí≥_Billing.py":{"content":"import streamlit as st\nfrom billing import render_billing_interface\nfrom auth import check_authentication\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Billing - CyberSec Platform\",\n    page_icon=\"üí≥\",\n    layout=\"wide\"\n)\n\n# Check authentication\nif not check_authentication():\n    st.stop()\n\n# Render the billing interface\nrender_billing_interface()\n","size_bytes":364}},"version":1}